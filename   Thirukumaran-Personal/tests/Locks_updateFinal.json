{
  "id": "625d0c42a162fb2205cebc54",
  "name": "Locks_updateFinal",
  "workspaceId": "625d0bf0a162fb2205cebc28",
  "version": 1,
  "createdBy": "625d0c01a162fb2205cebc36",
  "lastUpdateBy": "625d0bf0a162fb2205cebc25",
  "lastUpdatedOn": "2022-04-25T09:11:20.116Z",
  "definition": {
    "protocol": "none",
    "clientId": "",
    "strategy": "Default",
    "settings": {
      "loopback": true
    },
    "model": {
      "currentState": "Init",
      "stateMap": {
        "Init": {
          "name": "Init",
          "isEnabled": true,
          "sender": "{\n  /*\n  CHANGELOG\n\n  10-02-22\n  - commented out getCodes in checkCodes function. \n  - added triggerGetCodes to lockFunctions to enable manual trigger. \n\n  08-02-2022 | 11:45\n\n  - enabled REST operations in the code\n  - wrapped setCodeRes in try..catch\n   */\n  console.log(\"SEQINFO: In Init state\");\n  console.log(\"ClientId : \", client());\n\n  state._$timestamp = new Date();\n  state.mailboxCleared = false;\n  \n  let config = glob.get(\"config\");\n  state._$iterationConfig = config?.iterationConfig?.lock || [];\n  state.SPEED_CONSTANT = config?.iterationConfig?.SPEED_CONSTANT;\n\n  state._$nextExecution = {};\n\n  state._$iterationConfig.forEach((obj) => {\n    obj.interval /= state.SPEED_CONSTANT;\n    state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n  });\n\n  state.localManualTriggerCount = 0\n\n  if (client() === 0) {\n    let manualTrigger = {\n      fun: \"\",\n      count: 0,\n      spread: 1,\n    };\n    await glob.set(\"Locks_manualTrigger\", manualTrigger);\n    await glob.set(\"Locks_manualTriggerCount\", 0);\n\n  }\n\n  //For testing purpose\n  //state.locks = await glob.get(\"G\" + client() + \"_Locks\") || { };\n  // This object will be initialized later in online state.\n  state.locks = {};\n  state.getCodeRetryCount = 0;\n\n\n  next(\"Helpers\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 0
        },
        "Finished": {
          "name": "Finished",
          "isEnabled": true,
          "sender": "\n{\n  console.log('SEQINFO: In Finished state')\n  glob.set('G' + client() + '_Locks', state.locks)\n  \n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 3
        },
        "Helpers": {
          "index": 1,
          "name": "Helpers",
          "isEnabled": true,
          "sender": "{\n  state.activeContactSensors = (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n  let contactSensors = Object.keys(state.activeContactSensors)\n\n  state.activeMotionSensors = (await glob.get(\"G\" + client() + \"_ActiveMotionSensors\")) || {};\n  let motionSensors = Object.keys(state.activeMotionSensors)\n\n  console.log(\"SEQINFO: In Helper state\");\n  state.helpers = {};\n\n  state.helpers.checkToken = async function () {\n    if (\n      !state.token ||\n      state.token?.token_exp <= Math.floor(Date.now() / 1000)\n    ) {\n      state.token = await glob.get(\"APItoken\");\n    }\n  };\n\n  state.helpers.clearMailbox = async function (thing_names) {\n    console.log(\"SEQINFO: Clearing mailboxes for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      let count = mailbox.count(\"\" + thing_name + \"_rx\");\n      metric.add(\"Mailbox_size\", count);\n      // mailbox.delete(\"\" + thing_name + \"_rx\");\n    });\n  };\n\n  state.helpers.checkIncoming = async function (thing_names) {\n    console.log(\"#SEQINFO: Checking mailboxes for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      let count = mailbox.count(\"\" + thing_name + \"_rx\");\n      metric.add(\"Mailbox_size\", count);\n\n      while ((await mailbox.count(\"\" + thing_name + \"_rx\")) > 0) {\n        let msg = await mailbox.pop(\"\" + thing_name + \"_rx\");\n        console.log(thing_name + \"_rx: \" + JSON.stringify(msg));\n        if (!msg) continue;\n\n        msg.thing_name = thing_name;\n        await protocol.sendPayload(msg);\n        delay(10);\n      }\n    });\n  };\n\n  state.helpers.checkCodes = async function (thing_names) {\n    thing_names.forEach(async (thing_name) => {\n      if (\n        Array.isArray(state.locks[thing_name].codes) &&\n        state.locks[thing_name].codes.length > 0\n      ) {\n        console.log(\"Lock \" + thing_name + \" has codes in state\");\n      } else {\n        // if (state.getCodeRetryCount > 2) {\n        //   console.log(\"Trying to fetch codes for Lock \" + thing_name);\n        //   try {\n        //     await state.helpers.getCodes(thing_name);\n        //     metric.add(\"Locks_getCodes\", 1);\n        //   } catch (e) {\n        //     console.log(\"ERR: Failed to get codes.\", e);\n        //   }\n        // } else {\n        //   console.log(\"Exhausted Retries for fetching codes\");\n        //   state.locks[thing_name].codes = []\n        // }\n\n        console.log(`Lock ${thing_name} has no codes in state. `);\n      }\n    });\n  };\n\n  state.helpers.publish = async function (payload, thing_name) {\n    if (!payload?.state) {\n      console.error(\"Skipped publishing message that contains no state\");\n      return false;\n    }\n\n    let msg = {\n      payload,\n      topic: \"$aws/things/\" + thing_name + \"/shadow/update\",\n    };\n\n    console.log(\"Publishing message\", JSON.stringify(msg, null, 2));\n    await mailbox.post(\"Gateway_\" + client() + \"_tx\", msg);\n    await metric.add(\"lock_message_published\");\n  };\n\n  state.helpers.handleRemoveLock = async function () {\n    let removeLocks = _.difference(\n      Object.keys(state.locks),\n      Object.keys(state.activeLocks)\n    );\n\n    console.log(\"INFO: Removing Locks \", removeLocks);\n\n    removeLocks.forEach(async (thing_name) => {\n      metric.add(\"Locks_removeLock\", 1);\n      try {\n        delete state.locks[thing_name];\n        console.log(\"Removed \", thing_name);\n      } catch (e) {\n        console.log(\"ERR: Failed to remove lock \", e);\n      }\n    });\n\n    console.log(\"INFO: Simulation now running for locks : \", state.locks);\n  };\n\n  state.helpers.checkManualTrigger = async function () {\n    let manualTrigger = await glob.get(\"Locks_manualTrigger\");\n\n    if (manualTrigger.count > state.localManualTriggerCount) {\n      console.log(\"INFO: Received Manual Trigger for \" + manualTrigger.fun);\n\n      let check = state._$iterationConfig.find(\n        (o) => o.fun === manualTrigger.fun\n      );\n\n      if (!check) {\n        console.log(\n          \"ERR: Invalid Manual Trigger. Function doesn't exist in iterationConfig.\"\n        );\n        return false;\n      } else {\n        state.pendingManualTriggerFunction = manualTrigger.fun;\n        state.startIteration = index() + 1;\n\n        state.clientBatch = Math.ceil(jobClients() / manualTrigger.spread);\n        ++state.localManualTriggerCount;\n        console.log(\"INFO: Set Pending Manual Trigger to \" + manualTrigger.fun);\n        // glob.incr(\"manualTriggerCount\",1);\n        metric.add(\"Locks_pendingManualTrigger\");\n      }\n    } else {\n      // state.manualTriggerFunction = \"\";\n    }\n    if (\n      !!state.pendingManualTriggerFunction &&\n      Math.floor(client() / state.clientBatch) == index() - state.startIteration\n    ) {\n      state.manualTriggerFunction = state.pendingManualTriggerFunction;\n      state.pendingManualTriggerFunction = false;\n      console.log(\n        \"INFO: Set State Manual Trigger to \" + state.manualTriggerFunction\n      );\n      glob.incr(\"Locks_manualTriggerCount\", 1);\n      metric.add(\"Locks_manualTrigger\");\n    } else {\n      state.manualTriggerFunction = \"\";\n    }\n  };\n\n  state.helpers.handleScheduledPayloads = async function (thing_names) {\n    state._$iterationConfig.forEach(async (obj) => {\n      if (\n        Date.now() >= state._$nextExecution[obj.fun] ||\n        obj.fun === state?.manualTriggerFunction\n      ) {\n        state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n\n        console.log(\"TRIGGER: \", obj.fun);\n        thing_names.forEach(async (thing_name) => {\n          if (!state.locks[thing_name].initialized) return;\n          if (!state.lockFunctions[obj.fun]) {\n            console.error(\n              \"Function name \" + obj.fun + \" scheduled but not defined\"\n            );\n            return;\n          }\n          state.helpers.publish(\n            await state.lockFunctions[obj.fun](thing_name),\n            thing_name\n          );\n        });\n      }\n    });\n  };\n\n  state.helpers.handleNewLock = async function () {\n    Object.keys(state.activeLocks).forEach(async (thing_name) => {\n      if (!Object.keys(state.locks).includes(thing_name)) {\n        console.log(\"INFO: Found New Lock : \", thing_name);\n        metric.add(\"Locks_newLock\", 1);\n        state.locks[thing_name] = state.activeLocks[thing_name];\n        await state.helpers.initLock(thing_name);\n      } else {\n        console.log(`${thing_name} already exists in state`);\n      }\n    });\n\n    console.log(\"INFO: Simulation running for locks : \", state.locks);\n  };\n\n  state.helpers.initLock = async function (thing_name) {\n    metric.add(\"Locks_initLock\", 1);\n    console.log(\"SEQINFO: Intializing lock : \", thing_name);\n\n    state.locks[thing_name] = {\n      ...state.locks[thing_name],\n      power_source: chance.pickone([\"main\", \"battery\", \"unknown\"]),\n    };\n\n      // let x = await state.lockFunctions.lockMode(thing_name);\n      // await state.helpers.publish(x, thing_name);\n\n      metric.add(\"Locks_lockMode\", 1);\n      delay(100);\n\n    //  x = await state.lockFunctions.signalStrength(thing_name);\n    //  await state.helpers.publish(x, thing_name);\n    //  metric.add(\"Locks_signalStrength\", 1);\n    //  delay(100);\n\n    //  x = await state.lockFunctions.powerSourceUpdate(thing_name);\n    //  await state.helpers.publish(x, thing_name);\n    //  metric.add(\"Locks_powerSourceUpdate\", 1);\n    //  delay(100);\n\n    // try {\n    //   await state.helpers.getCodes(thing_name);\n    //   await state.lockFunctions.codeSetStatus(thing_name);\n    //   metric.add(\"Locks_getCodes\", 1);\n    // }\n    // catch (e) {\n    //   console.log(\"ERR: Failed to get codes and send set status.\", e.message)\n    // }\n\n    state.locks[thing_name].initialized = true;\n  };\n\n  state.helpers.getCodes = async function (thing_name) {\n    // console.error(\"SEQINFO: Skipped Fetching codes for \", thing_name);\n    // let lockId = thing_name.substring(thing_name.indexOf(\"-\") + 1);\n\n    let url =\n      \"https://keyless.rentlypt.com/api/devices/\" +\n      thing_name +\n      \"/all_codes\";\n    let options = {\n      headers: {\n        \"Content-type\": \"application/json\",\n        //\"Authorization\": \"Bearer \"+state.token\n      },\n    };\n    try {\n      state.locks[thing_name].codes = await rest.get(url, options);\n      //state.locks[thing_name].codes = {};\n      await metric.add(\"Locks_getCodesReqSent\");\n      console.log(\"Codes are: \", state.locks[thing_name].codes);\n      // await state.lockFunctions.codeSetStatus(thing_name);\n      return true;\n    } catch (e) {\n      console.error(\"ERR: getting codes\", e.message);\n      await metric.add(\"Locks_getCodesReqFailed\");\n\n      state.getCodeRetryCount++;\n    }\n  };\n\n  state.helpers.deleteCode = async function (thing_name) {\n    if (\n      !(\n        Array.isArray(state.locks[thing_name].codes) &&\n        state.locks[thing_name].codes.length > 0\n      )\n    ) {\n      console.log(\"No codes to delete\");\n      return false;\n    }\n    let delCode = chance.pickone(state.locks[thing_name].codes);\n    let lockId = thing_name.substring(thing_name.indexOf(\"-\") + 1);\n\n    let url =\n      \"https://keyless.rentlypt.com/api/devices/\" +\n      lockId +\n      \"/lock_codes/\" +\n      delCode.id;\n    let options = {\n      headers: {\n        \"Content-type\": \"application/json\",\n        Authorization: \"Bearer \" + state.token.apiToken,\n      },\n    };\n    try {\n      //let res = rest.delete(url, {}, options);\n      let res = {};\n    } catch (e) {\n      console.error(\"ERR: getting codes\", e.message);\n    }\n    let x = await state.lockFunctions.codeUnset(delCode, thing_name);\n    state.helpers.publish(x, thing_name);\n  };\n\n  state.helpers.setCode = async function (thing_name) {\n    let lockId = thing_name.substring(thing_name.indexOf(\"-\") + 1);\n\n    let obj = {};\n\n    state.setCode = state.setCode || \"NeverExpires\";\n\n    if (state.setCode === \"SpecificPeriod\") {\n      obj = {\n        name: \"SpecificPeriod\",\n        security_code: chance.integer({\n          min: 10000,\n          max: 99999,\n        }),\n        trigger_type: \"Disarm\",\n        code_type: \"property_level_code\",\n        from_time: \"2020-05-07T23:30:00.000-07:00\",\n        timestamp: 1588943465920,\n        to_time: \"2022-05-09T23:59:00.000-07:00\",\n        validity_type: \"Specific Period\",\n      };\n      state.setCode = false;\n    } else if (state.setCode === \"DayOfWeek\") {\n      obj = {\n        name: \"DailyRepeat 123\",\n        security_code: chance.integer({\n          min: 10000,\n          max: 99999,\n        }),\n        trigger_type: \"Disarm\",\n        code_type: \"property_level_code\",\n        schedule_details_info: [\n          {\n            d: \"0\",\n            f: \"14:59\",\n            t: \"23:59\",\n          },\n          {\n            d: \"1\",\n            f: \"00:00\",\n            t: \"23:59\",\n          },\n        ],\n        validity_type: \"By Day of Week\",\n      };\n    } else if (state.setCode === \"NeverExpires\") {\n      obj = {\n        name: \"Never Expire Code\",\n        security_code: chance.integer({\n          min: 10000,\n          max: 99999,\n        }),\n        validity_type: \"Never Expires\",\n        trigger_type: \"Disarm\",\n        code_type: \"staff_code\",\n      };\n    }\n    let url =\n      \"https://keyless.rentlypt.com/api/devices/\" +\n      lockId +\n      \"/lock_codes\";\n    let options = {\n      headers: {\n        \"content-type\": \"application/json\",\n        Authorization: \"Bearer \" + state?.token?.apiToken,\n      },\n    };\n\n    console.log(\"Sending setCode req to \" + url + \" with options \" + options);\n    let setCodeRes = {};\n\n    try {\n      setCodeRes = await rest.post(url, obj, options);\n    } catch (e) {\n      console.error(e);\n    }\n\n    console.log(\"Set Code Response: \", setCodeRes);\n    if (setCodeRes?.success) {\n      try {\n        await state.helpers.getCodes(thing_name);\n        await state.helpers.sendSetCodeRes(setCodeRes, thing_name);\n      } catch (e) {\n        console.log(\"ERR: error sendSetCodeRes \", e);\n      }\n    } else {\n      console.log(\"ERR: Failed to set code\");\n    }\n\n    state.setCode = false;\n  };\n  state.helpers.sendSetCodeRes = async function (setCodeRes, thing_name) {\n    console.log(\"sending response for code \", setCodeRes.id);\n\n    if (\n      Array.isArray(state.locks[thing_name].codes) &&\n      state.locks[thing_name].codes.length > 0\n    ) {\n      state.locks[thing_name].codes.forEach(async (code) => {\n        if (code.id === setCodeRes.id) {\n          let x = {\n            state: {\n              reported: {\n                thing_name,\n                status: {\n                  codes: {\n                    [code.slot]: code.security_code,\n                  },\n                },\n                updateTime: state._$timestamp.toISOString(),\n              },\n            },\n          };\n          await state.helpers.publish(x, thing_name);\n          console.log(\"Set code res sent : \", x);\n        }\n      });\n    } else {\n      console.log(\"ERR: No lock codes available for \" + thing_name);\n    }\n  };\n\n  let lockFunctions = {};\n  //UPDATE\n  lockFunctions.authUnlockSelfShow = async function (thing_name) {\n    if (\n      Array.isArray(state.locks[thing_name].selfShowCodes) &&\n      state.locks[thing_name].selfShowCodes.length > 0\n    ) {\n      code_slot = chance.pickone(state.locks[thing_name].selfShowCodes);\n    }\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            mode: {\n              type: \"unlocked\",\n              source: \"keypad\",\n              slot: code_slot,\n            },\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    await state.helpers.publish(res, thing_name);\n    \n    let x = await state.lockFunctions.replaceCode(thing_name, code_slot);\n    await state.helpers.publish(x, thing_name);\n\n    contactSensors.forEach(async (contactSensor) => {\n      let lockStatus = \"unlocked\"\n      let lock = thing_name\n      mailbox.post(\"\" + contactSensor + \"_cmd\", { lock, lockStatus });\n    })\n\n    // motionSensors.forEach(async (motionSensor) => {\n    //   let lockStatus = \"unlocked\"\n    //   let lock = thing_name\n    //   mailbox.post(\"\" + motionSensor + \"_cmd\", { lock, lockStatus });\n    // })\n    \n    return true;\n  };\n\n  lockFunctions.authUnlockCloud = async function (thing_name, command) {\n    // This needs to be triggered from the rently side\n    // response handler needs to capture the agent_id to be used in this payload\n\n    // let code = chance.pickone(state.codes)\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            mode: command,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    return res;\n  };\n\n  lockFunctions.authUnlockManual = async function (thing_name) {\n    let code = {\n      slot: 27,\n      name: \"\",\n    };\n\n    if (\n      Array.isArray(state.locks[thing_name].codes) &&\n      state.locks[thing_name].codes.length > 0\n    ) {\n      code = chance.pickone(state.locks[thing_name].codes);\n    }\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            mode: {\n              type: \"unlocked\",\n              source: \"keypad\",\n              slot: code.slot,\n              name: code.name,\n            },\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    contactSensors.forEach(async (contactSensor) => {\n      let lockStatus = \"unlocked\"\n      let lock = thing_name\n      mailbox.post(\"\" + contactSensor + \"_cmd\", { lock, lockStatus });\n    })\n\n    // motionSensors.forEach(async (motionSensor) => {\n    //   let lockStatus = \"unlocked\"\n    //   let lock = thing_name\n    //   mailbox.post(\"\" + motionSensor + \"_cmd\", { lock, lockStatus });\n    // })\n\n    return res;\n  };\n\n  lockFunctions.unauthUnlockManual = async function (thing_name) {\n    let authSlots = [];\n    if (\n      Array.isArray(state.locks[thing_name].codes) &&\n      state.locks[thing_name].codes.length > 0\n    ) {\n      code = chance.pickone(state.locks[thing_name].codes);\n      state.locks[thing_name].codes.forEach((code) => {\n        authSlots.push(code.slot);\n      });\n    }\n\n    let slot = 27;\n\n    while (authSlots.includes(slot)) {\n      console.log(\"Code exists with slot \", slot);\n      slot = chance.integer({\n        min: 0,\n        max: 100,\n      });\n    }\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            mode: {\n              type: \"unlocked\",\n              source: \"physical\",\n              slot,\n            },\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    contactSensors.forEach(async (contactSensor) => {\n      let lockStatus = \"unlocked\"\n      let lock = thing_name\n      mailbox.post(\"\" + contactSensor + \"_cmd\", { lock, lockStatus });\n    })\n\n    motionSensors.forEach(async (motionSensor) => {\n      let lockStatus = \"unlocked\"\n      let lock = thing_name\n      mailbox.post(\"\" + motionSensor + \"_cmd\", { lock, lockStatus });\n    })\n\n    return res;\n  };\n\n  lockFunctions.lockMode = async function (thing_name) {\n    let typeMode = chance.pickone([\"unlocked\", \"locked\"])\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            mode: {\n              type: typeMode,\n              source: chance.pickone([\"auto\", \"physical\"]),\n            },\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    contactSensors.forEach(async (contactSensor) => {\n      let lockStatus = typeMode\n      let lock = thing_name\n      mailbox.post(\"\" + contactSensor + \"_cmd\", { lock, lockStatus });\n    })\n\n    // motionSensors.forEach(async (motionSensor) => {\n    //   let lockStatus = \"unlocked\"\n    //   let lock = thing_name\n    //   mailbox.post(\"\" + motionSensor + \"_cmd\", { lock, lockStatus });\n    // })\n\n    return res;\n  };\n\n  lockFunctions.codeSetStatus = async function (thing_name) {\n    state._$payloadBuffer = [];\n\n    if (\n      Array.isArray(state.locks[thing_name].codes) &&\n      state.locks[thing_name].codes.length > 0\n    ) {\n      state.locks[thing_name].codes.forEach(async (code) => {\n        let res = {\n          state: {\n            reported: {\n              thing_name,\n              status: {\n                codes: {\n                  [code.slot]: code.security_code,\n                },\n              },\n              updateTime: state._$timestamp.toISOString(),\n            },\n          },\n        };\n        // state._$payloadBuffer.push(res);\n        await state.helpers.publish(res, thing_name);\n      });\n    } else {\n      console.log(\"No codes for lock \" + thing_name);\n      await state.helpers.getCodes(thing_name);\n    }\n\n    return true;\n  };\n\n  // for delete. do not add to iterationConfig\n  lockFunctions.codeUnset = async function (code, thing_name) {\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            codes: {\n              [code.slot]: \"\",\n            },\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  lockFunctions.powerSourceUpdate = async function (thing_name) {\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            power_source: state.locks[thing_name].power_source,\n          },\n        },\n      },\n    };\n    if (state.locks[thing_name].power_source === \"battery\") {\n      // let obj = {\n      //   fun: \"batteryStatus\",\n      // };\n      // state._$queue.push(obj);\n      let x = await state.lockFunctions.batteryStatus(thing_name);\n      await state.helpers.publish(x, thing_name);\n    }\n\n    return res;\n  };\n\n  lockFunctions.batteryStatus = async function (thing_name) {\n    if (!state.locks[thing_name].battery) {\n      let battery = [\"critical\", \"low\", \"change-battery\", \"number\"];\n\n      state.locks[thing_name].battery = chance.pickone(battery);\n    }\n    if (state.locks[thing_name].battery === \"number\") {\n      state.locks[thing_name].battery = chance.integer({\n        min: 1,\n        max: 100,\n      });\n    }\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            battery: state.locks[thing_name].battery,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  lockFunctions.signalStrength = async function (thing_name) {\n    state.locks[thing_name].zwave_signal = chance.integer({\n      min: -1,\n      max: 5,\n    });\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            zwave_signal: state.locks[thing_name].zwave_signal,\n          },\n        },\n      },\n    };\n    return res;\n  };\n\n  lockFunctions.replaceCode = async function (thing_name, slot) {\n    code_new = chance.integer({ min: 100000, max: 999999 });\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            codes: {\n              [code.slot]: code_new,\n            },\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    return res;\n  };\n\n  lockFunctions.triggerGetCodes = async function (thing_name) {\n    console.log(\"Triggering Get Codes for \" + thing_name);\n    state.helpers.getCodes(thing_name);\n  };\n\n  state.lockFunctions = lockFunctions;\n  next(\"Online\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        },
        "Online": {
          "index": 2,
          "name": "Online",
          "isEnabled": true,
          "sender": "{\n  console.log(\n    `SEQINFO: In Online state | Iteration ${index()} Client ${client()}`\n  );\n\n  \n  try {\n    state.activeLocks = (await glob.get(\"G\" + client() + \"_ActiveLocks\")) || {};\n    state._$timestamp = new Date();\n\n    console.log(\"SEQINFO: Checking token\");\n    await state.helpers.checkToken();\n    await state.helpers.checkManualTrigger();\n\n    if (\n      Object.keys(state.activeLocks).length < Object.keys(state.locks).length\n    ) {\n      console.log(\"INFO : Lock(s) removed from gateway\");\n\n      await state.helpers.handleRemoveLock();\n    } else if (\n      Object.keys(state.activeLocks).length > Object.keys(state.locks).length\n    ) {\n      console.log(\"INFO : New Lock added to gateway\");\n\n      await state.helpers.handleNewLock();\n    }\n\n    console.log(\"Locks in state : \", Object.keys(state.locks));\n\n    if (Object.keys(state.locks).length > 0) {\n      console.log(\"SEQINFO: Checking Lock codes\");\n      state.helpers.checkCodes(Object.keys(state.locks));\n\n      let timerS = Date.now();\n      console.log(\"SEQINFO: Checking Incoming messages\");\n\n      if (!state.mailboxCleared) {\n        await state.helpers.clearMailbox(Object.keys(state.locks));\n        console.log(\"Mailbox successfully cleared upon start\");\n        state.mailboxCleared = true;\n      }\n\n      await state.helpers.checkIncoming(Object.keys(state.locks));\n      let timerE = Date.now();\n      metric.add(\"Locks_checkIncoming\", timerE - timerS);\n\n      console.log(\"SEQINFO: Running scheduled Payloads\");\n      try {\n        await state.helpers.handleScheduledPayloads(Object.keys(state.locks));\n      } catch (e) {\n        console.log(\"ERR: error in scheduled function\", e);\n      }\n    } else {\n      console.log(\"No Locks in state\");\n    }\n  } catch (e) {\n    console.log(\"ERR: In Online State\", e);\n  }\n  // state.helpers.publish(\"ping\", \"hello\")\n\n  //if (iteration() === jobClients() - 2) next(\"Finished\"); // Trigger state transition in penultimate iteration\n}\n",
          "receiver": "{\n  metric.add(\"Locks_RHTriggered\");\n  console.log(\"RH recieved: \", response);\n  response = JSON.parse(response);\n  let { topic, res } = response;\n\n  console.log(\"TOPIC: \", topic);\n  console.log(\"RESPONSE: \", res);\n\n  state.activeContactSensors = (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n  let contactSensors = Object.keys(state.activeContactSensors)\n\n  // res = await JSON.parse(res)\n\n  if (!res?.state || !topic) {\n    console.log(\"ERR: No state in response\");\n    // return;\n  }\n\n  state._$timestamp = new Date();\n\n  let thing_name = topic.split(\"/\")[2] || \"\";\n  console.log(\"Received Message for :\", thing_name);\n\n  if (topic === \"$aws/things/\" + thing_name + \"/shadow/update/delta\") {\n    metric.add(\"Locks_receivedDelta\");\n\n    if (res && res.state && res.state.commands) {\n      let commands = res.state.commands;\n\n      metric.add(\"Locks_deltaCommandRX\");\n\n      console.log(\"COMMANDS: \", commands);\n      let timestamps = Object.keys(commands);\n\n      timestamps.forEach(async (timestamp) => {\n        if (commands[timestamp].mode === \"unlock\") {\n          console.log(\"Received Cloud Unlock command for Lock \" + thing_name);\n          state.locks[thing_name].cloudCommand = {\n            type: \"unlocked\",\n            source: \"cloud\",\n            agent_id: commands[timestamp].agent_id,\n          };\n          // state._$queue.push({\n          //   fun: \"authUnlockCloud\",\n          // });\n\n          let response = await state.lockFunctions.authUnlockCloud(\n            thing_name,\n            state.locks[thing_name].cloudCommand\n          );\n          console.log(\n            \"Sending cloud unlock response\",\n            JSON.stringify(response)\n          );\n\n          contactSensors.forEach(async (contactSensor) => {\n            let lockStatus = \"unlocked\"\n            let lock = thing_name\n            mailbox.post(\"\" + contactSensor + \"_cmd\", { lock, lockStatus});\n          })\n\n          await state.helpers.publish(response, thing_name);\n          metric.add(\"Locks_authUnlockCloud\");\n        } else if (commands[timestamp].mode === \"lock\") {\n          console.log(\"Received Cloud Unlock command for Lock \" + thing_name);\n\n          state.locks[thing_name].cloudCommand = {\n            type: \"locked\",\n            source: \"cloud\",\n            agent_id: commands[timestamp].agent_id,\n          };\n          // state._$queue.push({\n          //   fun: \"authUnlockCloud\",\n          // });\n          let response = await state.lockFunctions.authUnlockCloud(\n            thing_name,\n            state.locks[thing_name].cloudCommand\n          );\n          console.log(\n            \"Sending cloud unlock response\",\n            JSON.stringify(response)\n          );\n          \n          contactSensors.forEach(async (contactSensor) => {\n            let lockStatus = \"locked\"\n            let lock = thing_name\n            mailbox.post(\"\" + contactSensor + \"_cmd\", { lock, lockStatus });\n          })\n\n          await state.helpers.publish(response, thing_name);\n          metric.add(\"Locks_authUnlockCloud\");\n        } else if (commands[timestamp].mode === \"get_battery\") {\n          console.log(\n            \"Received Cloud get_battery command for Lock \" + thing_name\n          );\n\n          // state._$queue.push({\n          //   fun: \"batteryStatus\",\n          // });\n          state.helpers.publish(\n            await state.lockFunctions.batteryStatus(thing_name),\n            thing_name\n          );\n          metric.add(\"Locks_batteryStatus\");\n        }\n      });\n    }\n    //UPDATE\n    if (\n      res &&\n      res.state &&\n      res.state.settings &&\n      res.state.settings.lock_codes_v2\n    ) {\n      //let lockId = thing_name.substring(thing_name.indexOf(\"-\") + 1);\n      let lockId = thing_name;\n      console.log(\"************pre******\");\n\n      let url =\n        \"https://keyless.rentlypt.com/api/devices/\" + lockId + \"/all_codes\";\n      let options = {\n        headers: {\n          \"Content-type\": \"application/json\"\n          // Authorization: \"Bearer \" + state.token,\n        },\n      };\n      \n      try {\n        console.log(\"************post******\");\n        state.locks[thing_name].codes = await rest.get(url, options);\n        console.log(\"afterpost\")\n        console.log(\"Codes: \", state.locks[thing_name].codes);\n        // await state.lockFunctions.codeSetStatus(thing_name);\n\n        let codeNumber = Object.keys(state.locks[thing_name].codes);\n        console.log(\"codeNUmber\",codeNumber);\n\n        console.log(\"Sending Code set status\");\n\n        codeNumber.forEach(async (code) => {\n          console.log(\n            \"Slot to be set: \" + state.locks[thing_name].codes[code].slot\n          );\n          let x = {\n            state: {\n              reported: {\n                thing_name,\n                status: {\n                  codes: {\n                    [state.locks[thing_name].codes[code].slot]:\n                      state.locks[thing_name].codes[code].security_code,\n                  },\n                },\n                updateTime: state._$timestamp.toISOString(),\n              },\n            },\n          };\n          await state.helpers.publish(x, thing_name);\n          console.log(\"Set code res sent : \", x);\n        });\n\n        url =\n          \"https://keyless.rentlypt.com/api/devices/\" +\n          lockId +\n          \"/lock_codes/status\";\n        options = {\n          headers: {\n            \"Content-type\": \"application/json\",\n            \"Authorization\": \"Bearer \"+ state.token\n          },\n        };\n        /*try {\n          console.log(\"pre1\")\n          state.locks[thing_name].codeStatus = await rest.get(url, options);\n          console.log(\"pre2\")\n          console.log(\"Code status: \", state.locks[thing_name].codeStatus);\n\n          assert(\n            state.locks[thing_name].codeStatus.thing_name === \"set\",\n            \"Code has not been set\"\n          );\n\n          return true;\n        } catch (e) {\n          console.log(\"erroringettingurl\")\n          console.error(\"ERR: Checking status\", e.message);\n        }*/\n      } catch (e) {\n        console.error(\"ERR: getting codes\", e.message);\n      }\n    }\n\n    if (res && res.state && res.state.settings && res.state.settings.rently) {\n      if (res.state.settings.rently === \"enable\") {\n        console.log(\"enteringrently\")\n        state.locks[thing_name].selfShowCodes =\n          res.state.settings.rently_codes;\n        console.log(\"RentlyCodesno\", res.state.settings.rently_codes);\n        state.nextRentlyBatch = Date.now + 14400000;\n        if (\n          Array.isArray(state.locks[thing_name].selfShowCodes) &&\n          state.locks[thing_name].selfShowCodes.length > 0\n        ) {\n          state.locks[thing_name].selfShowCodes.forEach(async (code,index) => {\n            code_new = chance.integer({ min: 100000, max: 999999 });\n\n            let x = {\n              state: {\n                reported: {\n                  thing_name,\n                  status: {\n                    codes: {\n                      [state.locks[thing_name].selfShowCodes[index]]: code_new,\n                    },\n                  },\n                  updateTime: state._$timestamp.toISOString(),\n                },\n              },\n            };\n            await state.helpers.publish(x, thing_name);\n            console.log(\"Set code res sent : \", x);\n          });\n        } else {\n          console.log(\"ERR: No lock codes available for \" + thing_name);\n        }\n      }\n    }\n\n    if (res && res.state) {\n      // state._$deltaState = res.state\n\n      // state._$queue.push({\n      //   fun: \"sendReported\"\n      // })\n      let x = {\n        state: {\n          reported: {\n            ...res.state,\n            thing_name,\n            updateTime: state._$timestamp.toISOString(),\n          },\n        },\n      };\n      // await state.helpers.publish(x, thing_name);\n      console.log(\"SEQINFO: Echo back sent\");\n    }\n  }\n}\n"
        }
      },
      "setup": "",
      "teardown": ""
    },
    "additionalPackages": {}
  },
  "history": [
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-18T06:59:14.366Z",
      "description": {
        "action": "Create"
      }
    },
    {
      "userId": "625d0bf0a162fb2205cebc25",
      "timestamp": "2022-04-25T09:11:20.116Z",
      "description": {
        "action": "update"
      }
    }
  ]
}