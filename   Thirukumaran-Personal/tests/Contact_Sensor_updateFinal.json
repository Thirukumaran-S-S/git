{
  "id": "625d0c58a162fb2205cebc5e",
  "name": "Contact_Sensor_updateFinal",
  "workspaceId": "625d0bf0a162fb2205cebc28",
  "version": 1,
  "createdBy": "625d0c01a162fb2205cebc36",
  "lastUpdateBy": "625d0c01a162fb2205cebc36",
  "lastUpdatedOn": "2022-04-18T06:59:36.935Z",
  "definition": {
    "protocol": "none",
    "clientId": "",
    "strategy": "Default",
    "settings": {
      "loopback": true
    },
    "model": {
      "currentState": "Init",
      "stateMap": {
        "Init": {
          "name": "Init",
          "isEnabled": true,
          "sender": "{\n  console.log(\n    `SEQINFO: In Init State - Client: ${client()} , Iteration: ${index()}`\n  );\n  state._$timestamp = new Date();\n  state.mailboxCleared = false;\n  let config = glob.get(\"config\");\n  state._$iterationConfig = config?.iterationConfig?.contact || [];\n  state.SPEED_CONSTANT = config?.iterationConfig?.SPEED_CONSTANT;\n\n  state._$nextExecution = {};\n  state.PAYLOADS = [];\n\n  state._$iterationConfig.forEach((obj) => {\n    obj.interval /= state.SPEED_CONSTANT;\n    state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n  });\n\n  if (client() === 0) {\n    let manualTrigger = {\n      fun: \"\",\n      count: 0,\n      spread: 1,\n    };\n    await glob.set(\"Contact_manualTrigger\", manualTrigger);\n    await glob.set(\"Contact_manualTriggerCount\", 0);\n\n  }\n  state.sirenAlert = false\n  state.ruleReceived = false\n  state.timeoutRaised = false\n  \n  state.contacts =  {};\n\n\n  next(\"Helpers\");\n  console.log(`SEQINFO: Completed Init State`);\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 0
        },
        "Finished": {
          "name": "Finished",
          "isEnabled": true,
          "sender": "\n{\n  console.log(`SEQINFO: In Helper State - Client: ${client()} , Iteration: ${index()}`)\n\n  glob.set(\"G\" + client() + \"_contacts\", state.contacts)\n\n  console.log(`SEQINFO: Completed Finished State`)\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 3
        },
        "Online": {
          "index": 2,
          "name": "Online",
          "isEnabled": true,
          "sender": "\n{\n  console.log(`SEQINFO: In Online State - Client: ${client()} , Iteration: ${index()}`)\n\n  state.activeContacts = (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n  state._$timestamp = new Date();\n\n  if (!state.mailboxCleared) {\n    await state.helpers.clearMailbox(Object.keys(state.contacts));\n    console.log(\"Mailbox successfully cleared upon start\");\n    state.mailboxCleared = true;\n  }\n\n  \n  await state.helpers.checkManualTrigger();\n  await state.helpers.checkAlert(Object.keys(state.contacts));\n  // await state.helpers.checkTimeout(Object.keys(state.contacts));\n\n\n  if (Object.keys(state.activeContacts).length < Object.keys(state.contacts).length) {\n    console.log(\"INFO : Contact(s) removed from gateway\");\n\n    await state.helpers.handleRemoveContact();\n  } else if (\n    Object.keys(state.activeContacts).length > Object.keys(state.contacts).length\n  ) {\n    console.log(\"INFO : New contact added to gateway\");\n    \n    await state.helpers.handleNewContact();\n   \n  }\n\n  console.log(\"contacts in state : \", Object.keys(state.contacts));\n\n  if (Object.keys(state.contacts).length > 0) {\n    // try {\n    //   await state.helpers.checkScheduleId(Object.keys(state.contacts))\n    // } catch (e) {\n    //   console.log(e)\n    // }\n    // try {\n    //   await state.helpers.updateState(Object.keys(state.contacts))\n    // }\n    // catch (e) {\n    //   console.log(\"ERR: error updating state. \", e)\n    // }\n\n    console.log(\"SEQINFO: Checking Incoming status\");\n    await state.helpers.checkIncomingCmd(Object.keys(state.contacts));\n\n    Object.keys(state.contacts).forEach(async (thing_name) => {\n      if (Date.now() >= state.nextAlert && state.contacts[thing_name].status == \"opened\" && state.checkTimeout == true) {\n        console.log(\"Contact sensor has been open for \" + state.timeout * 100 + \" seconds, sending alert to Thermostat\")\n\n        let trigger = true;\n        mailbox.post(\"\" + state.thermostatTN + \"_cmd\", { trigger });\n        state.triggerAlerted = true;\n        // state.timeoutRaised = true;\n        state.checkTimeout = false;\n      }\n\n      if (state.triggerAlerted && state.triggerAlerted == true && state.contacts[thing_name].status == \"closed\") {\n        console.log(\"Contact sensor closed after timeout, sending update to Thermostat\")\n\n        let contactClosed = true;\n        mailbox.post(\"\" + state.thermostatTN + \"_cmd\", { contactClosed });\n        state.triggerAlerted = false;\n        // state.timeoutRaised = false;\n      }\n\n      if (state.lastMode && state.lastMode == \"closed\") {\n        if (state.ruleReceived == true && state.contacts[thing_name].status == \"opened\") {\n          state.checkTimeout = true;\n          state.nextAlert = Date.now() + (parseInt(state.timeout) * 100);\n        }\n      }\n      state.lastMode = state.contacts[thing_name].status;\n    });\n    \n    \n\n    let timerS = Date.now();\n    console.log(\"SEQINFO: Checking Incoming messages\");\n    await state.helpers.checkIncoming(Object.keys(state.contacts));\n    let timerE = Date.now();\n    metric.add(\"contacts_checkIncoming\", timerE - timerS);\n\n    console.log(\"SEQINFO: Running scheduled Payloads\");\n    try {\n      await state.helpers.handleScheduledPayloads(Object.keys(state.contacts));\n    } catch (e) {\n      console.log(\"ERR: error in scheduled function\", e);\n    }\n  } else {\n    console.log(\"No contacts in state\");\n  }\n\n  // state.helpers.publish(\"ping\", \"hello\")\n\n  // if (iteration() === jobClients() - 2) next(\"Finished\"); // Trigger state transition in penultimate iteration\n  // console.log(`SEQINFO: Completed Online State`)\n}\n",
          "receiver": "{\n    metric.add(\"ContactSensor_RHTriggered\");\n    console.log(\"RH received: \", response);\n    response = JSON.parse(Response)\n    let { topic, res } = response;\n\n    console.log(\"TOPIC: \", topic);\n    console.log(\"RESPONSE: \", res);\n\n    if (!(res?.state) || !topic) {\n        console.log(\"ERR: No state in response\");\n        // return;\n    }\n\n    state._$timestamp = new Date();\n\n    let thing_name = topic.split(\"/\")[2] || \"\";\n    console.log(\"Received Message for :\", thing_name);\n\n    if (topic === \"$aws/things/\" + thing_name + \"/shadow/update/delta\") {\n        metric.add(\"ContactSensors_receivedDelta\");\n\n        if (res && res.state && res.state.commands) {\n            let commands = res.state.commands;\n\n            metric.add('ContactSensors_deltaCommandRX')\n\n            console.log(\"COMMANDS: \", commands);\n            let timestamps = Object.keys(commands);\n\n            timestamps.forEach(async (timestamp) => {\n                if (commands[timestamp].mode === \"get_battery\") {\n                    console.log(\"Received Cloud get_battery command for CS \" + thing_name);\n                    state.helpers.publish(await state.contactFunctions.sendBattery(thing_name), thing_name);\n                    metric.add(\"ContactSensor_batteryStatus\");\n\n                }\n            });\n        }\n\n        if (res && res.state) {\n            // state._$deltaState = res.state\n\n            // state._$queue.push({\n            //   fun: \"sendReported\"\n            // })\n            let x = {\n                state: {\n                    reported: {\n                        ...res.state,\n                        thing_name,\n                        updateTime: state._$timestamp.toISOString(),\n                    },\n                },\n            };\n             await state.helpers.publish(x, thing_name);\n            console.log(\"SEQINFO: Echo back sent\");\n        }\n    }\n\n}"
        },
        "Helpers": {
          "index": 1,
          "name": "Helpers",
          "isEnabled": true,
          "sender": "{\n  // TODO : queues. token\n  console.log(\n    `SEQINFO: In Helper State - Client: ${client()} , Iteration: ${index()}`\n  );\n  state.helpers = {};\n\n  state.activeLocks = (await glob.get(\"G\" + client() + \"_ActiveLocks\")) || {};\n  state.activeSirens = (await glob.get(\"G\" + client() + \"_ActiveSirens\")) || {};\n\n\n  state.helpers.checkAlert = async function (thing_names) {\n   \n    console.log(\"SEQINFO: Checking for alert \");\n    thing_names.forEach(async (thing_name) => {\n      if (state.contacts[thing_name].status == \"closed\") {\n        state.sirenAlert = \"false\"\n      }\n      console.log(\"receivedalert contact status\")\n      if (state.monitoring == \"arm_out\")   {\n        console.log(\"ISmonitoring arm_out\")\n        if (state.contacts[thing_name].status == \"opened\" && state.sirenAlert == \"false\") {\n          console.log(\"Sending alert to siren\")\n          let sirens = Object.keys(state.activeSirens)\n          sirens.forEach(async (siren) => {\n            let contactSensor = thing_name;\n            let status = \"opened\";\n            mailbox.post(\"\" + siren + \"_cmd\", { contactSensor, status });\n            console.log(\"Alert sent to: \" + contactSensor)\n            state.sirenAlert = \"true\"\n          })\n        }\n      }\n    });\n  }\n\n  // state.helpers.checkTimeout = async function (thing_names) {\n  //   console.log(\"SEQINFO: Checking timeout for: \", thing_names);\n  //   thing_names.forEach(async (thing_name) => {\n  //     if (state.contacts[thing_name].status == \"opened\" && state.timeoutRaised == false && state.ruleReceived == true) {\n  //       console.log(\"Contact sensor is open, setting timeout for \" + state.timeout/10 + \" seconds\")\n  //       state.nextAlert = Date.now() + (parseInt(state.timeout) * 100)\n  //       state.timeoutRaised = true\n  //     }\n  //   });\n  // }\n\n  state.helpers.clearMailbox = async function (thing_names) {\n    console.log(\"SEQINFO: Clearing mailboxes for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      let count = mailbox.count(\"\" + thing_name + \"_rx\");\n      metric.add(\"Mailbox_size\", count);\n      mailbox.delete(\"\" + thing_name + \"_rx\");\n    });\n  }\n\n  state.helpers.checkIncoming = async function (thing_names) {\n    console.log(\"SEQINFO: Checking mailboxes for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      while (mailbox.count(\"\" + thing_name + \"_rx\") > 0) {\n        let msg = await mailbox.pop(\"\" + thing_name + \"_rx\");\n        msg.thing_name = thing_name;\n        await protocol.sendPayload(msg);\n      }\n    });\n  };\n\n  state.helpers.checkIncomingCmd = async function (thing_names) {\n    console.log(\"checkIncomingCmd SEQINFO: Checking mailboxes for: \", thing_names);\n    console.log(mailbox.count(\"\" + thing_names[0] + \"_cmd\"))\n    thing_names.forEach(async (thing_name) => {\n      console.log(mailbox.count(\"\" + thing_name + \"_cmd\"));\n      while (mailbox.count(\"\" + thing_name + \"_cmd\") > 0) {\n        console.log(\"gettingcontactstatus\")\n        let msg = await mailbox.pop(\"\" + thing_name + \"_cmd\");\n        console.log(\"msg.lock\",msg.lock)\n        if (msg.lock) {\n          let lockTN = msg.lock\n          let lockStatus = msg.lockStatus\n\n          let activeLocks = Object.keys(state.activeLocks)\n          console.log(\"lock and lockTN\", lockTN, lockStatus)\n          activeLocks.forEach(async (lock) => {\n            if (lock == lockTN) {\n              if (lockStatus == \"locked\") {\n                state.contacts[thing_name].status = \"closed\"\n                console.log(\"CONTACTClosed\");\n              }\n              else if (lockStatus == \"unlocked\") {\n                state.contacts[thing_name].status = \"opened\"\n                console.log(\"CONTACTopen\")\n              }\n            }\n          })\n\n          res = {\n            state: {\n              reported: {\n                thing_name,\n                status: {\n                  contact_status: state.contacts[thing_name].status,\n                },\n                updateTime: state._$timestamp.toISOString(),\n              },\n            },\n          };\n\n          await state.helpers.publish(res, thing_name);\n        }\n\n        if (msg.thermostat) {\n          console.log(\"Received timeout from Thermostat, stored in state \")\n          state.ruleReceived = true\n          state.thermostatTN = msg.thermostat\n          state.timeout = msg.timeout\n        }\n\n        if (msg.gateway && msg.sensors) {\n          console.log(\"CONTACTGATEWAY execu\")\n          state.gatewayTN = msg.gateway\n          state.sensors = msg.sensors\n        }\n        if (msg.monitoring) {\n          state.monitoring = msg.monitoring\n        }\n      }\n    });\n    console.log(\"msg.gateway\", state.gatewayTN)\n    console.log(\"msg.sensors\", state.sensors)\n    console.log(\"msg.monitoring\", state.monitoring)\n  };\n\n  state.helpers.checkManualTrigger = async function () {\n    let manualTrigger = await glob.get(\"Contact_manualTrigger\");\n\n    if (manualTrigger.count > state.localManualTriggerCount) {\n      console.log(\"INFO: Received Manual Trigger for \" + manualTrigger.fun);\n\n      let check = state._$iterationConfig.find(\n        (o) => o.fun === manualTrigger.fun\n      );\n\n      if (!check) {\n        console.log(\n          \"ERR: Invalid Manual Trigger. Function doesn't exist in iterationConfig.\"\n        );\n        return false;\n      } else {\n        state.pendingManualTriggerFunction = manualTrigger.fun;\n        state.startIteration = index() + 1;\n\n        state.clientBatch = Math.ceil(jobClients() / manualTrigger.spread);\n        ++state.localManualTriggerCount;\n        console.log(\"INFO: Set Pending Manual Trigger to \" + manualTrigger.fun);\n        // glob.incr(\"manualTriggerCount\",1);\n        metric.add(\"Thermostats_pendingManualTrigger\");\n      }\n    } else {\n      // state.manualTriggerFunction = \"\";\n    }\n    if (\n      !!state.pendingManualTriggerFunction &&\n      Math.floor(client() / state.clientBatch) == index() - state.startIteration\n    ) {\n      state.manualTriggerFunction = state.pendingManualTriggerFunction;\n      state.pendingManualTriggerFunction = false;\n      console.log(\n        \"INFO: Set State Manual Trigger to \" + state.manualTriggerFunction\n      );\n      glob.incr(\"Contact_manualTriggerCount\", 1);\n      metric.add(\"Contact_manualTrigger\");\n    } else {\n      state.manualTriggerFunction = \"\";\n    }\n  };\n\n  state.helpers.publish = async function (payload, thing_name) {\n    let msg = {\n      payload,\n      topic: \"$aws/things/\" + thing_name + \"/shadow/update\",\n    };\n    if (state.monitoring == \"arm_out\" || state.monitoring == \"disarm\" ) {\n      state.PAYLOADS.push(payload)\n      await mailbox.post(\"Gateway_\" + client() + \"_tx\", msg);\n      console.log(\"CS init complete\");\n    }\n  };\n\n\n  state.helpers.handleRemoveContact = async function () {\n    let removeContacts = _.difference(\n      Object.keys(state.contacts),\n      Object.keys(state.activeContacts)\n    );\n\n    console.log(\"INFO: Removing Contacts \", removeContacts);\n\n    removeContacts.forEach(async (thing_name) => {\n      metric.add(\"Conact_removal\", 1);\n      try {\n        delete state.contacts[thing_name];\n        console.log(\"Removed \", thing_name);\n      } catch (e) {\n        console.log(\"ERR: Failed to remove contactsensor \", e);\n      }\n    });\n\n    console.log(\n      \"INFO: Simulation now running for Contacts : \",\n      state.contacts\n    );\n  };\n\n  state.helpers.handleNewContact = async function () {\n    Object.keys(state.activeContacts).forEach(async (thing_name) => {\n      if (!Object.keys(state.contacts).includes(thing_name)) {\n        console.log(\"INFO: Found New Contact : \", thing_name);\n        metric.add(\"Contact_new\", 1);\n         state.contacts[thing_name] = state.activeContacts[thing_name];\n        await state.helpers.initContact(thing_name);\n      } else {\n        console.log(`${thing_name} already exists in state`);\n      }\n    });\n\n    console.log(\n      \"INFO: Simulation running for contactsensros : \",\n      state.contacts\n    );\n  };\n\n  state.helpers.initContact = async function (thing_name) {\n    metric.add(\"Contact_init\", 1);\n    console.log(\"SEQINFO: Intializing contact : \", thing_name);\n\n    let x = state.contactFunctions.sendCSstatus(thing_name);\n    await state.helpers.publish(x, thing_name);\n    //metric.add(\"Contact_sendStatus\", 1);\n    console.log(\"post send status\");\n   \n\n    // x = state.contactFunctions.signalStrength(thing_name);\n    // await state.helpers.publish(x, thing_name);\n    // //metric.add(\"Contact_signalStrength\", 1);\n    // console.log(\"post signal strength\");\n    \n\n    x = state.contactFunctions.sendBattery(thing_name);\n    await state.helpers.publish(x, thing_name);\n    //metric.add(\"Contact_sendBattery\", 1);\n    console.log(\"post send battery\");\n    \n\n    \n  };\n\n  state.helpers.handleScheduledPayloads = async function (thing_names) {\n    state._$iterationConfig.forEach(async (obj) => {\n      if (\n        Date.now() >= state._$nextExecution[obj.fun] ||\n        obj.fun === state?.manualTriggerFunction\n      ) {\n        state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n\n        console.log(\"TRIGGER: \", obj.fun);\n        //metric.add(\"Contact_\" + obj.fun, 1);\n        thing_names.forEach(async (thing_name) => {\n          state.helpers.publish(\n            state.contactFunctions[obj.fun](thing_name),\n            thing_name\n          );\n          \n\n        });\n      }\n    });\n  };\n\n  let contactFunctions = {};\n\n  contactFunctions.sendCSstatus = function (thing_name) {\n    state.contacts[thing_name].status = chance.pickone([\n      \"opened\",\n      \"closed\"\n    ]);\n\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            contact_status: state.contacts[thing_name].status,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  contactFunctions.wakeupInterval = function (thing_name) {\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            wakeup_interval: 43200\n          }\n        }\n      }\n    };\n    return res;\n  };\n\n  contactFunctions.sendAlaram = function (thing_name) {\n    state.contacts[thing_name].alaram_type = chance.pickone([\n      \"normal\",\n      \"tampered\"\n    ]);\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            alaram: state.contacts[thing_name].alaram_type,\n          }\n        }\n      }\n    };\n    return res;\n  };\n\n  contactFunctions.signalStrength = function (thing_name) {\n    state.contacts[thing_name].zwave_signal = chance.integer({\n      min: -1,\n      max: 5,\n    });\n\n    let res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            zwave_signal: state.contacts[thing_name].zwave_signal,\n          },\n        },\n      },\n    };\n    return res;\n  };\n\n  contactFunctions.sendBattery = function (thing_name) {\n    if (!state.contacts[thing_name].battery) {\n      state.contacts[thing_name].battery = chance.integer({\n        min: 1,\n        max: 100,\n      });\n    }\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            battery: state.contacts[thing_name].battery,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  contactFunctions.sendPowerSource = function (thing_name) {\n    state.contacts[thing_name].power_source = chance.pickone([\n      \"main\",\n      \"battery\",\n      \"unknown\",\n    ]);\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            power_source: state.contacts[thing_name].power_source,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    if (state.contacts[thing_name].power_source === \"battery\") {\n      let x = state.contactFunctions.sendBattery(thing_name);\n      state.helpers.publish(x, thing_name);\n    }\n    return res;\n  };\n\n  state.contactFunctions = contactFunctions;\n\n  next(\"Online\");\n  console.log(`SEQINFO: Completed Helper State`);\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        }
      },
      "setup": "",
      "teardown": ""
    },
    "additionalPackages": {}
  },
  "history": [
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-18T06:59:36.935Z",
      "description": {
        "action": "Create"
      }
    }
  ]
}