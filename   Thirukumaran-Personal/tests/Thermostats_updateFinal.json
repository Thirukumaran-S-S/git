{
  "id": "625d0c4ea162fb2205cebc58",
  "name": "Thermostats_updateFinal",
  "workspaceId": "625d0bf0a162fb2205cebc28",
  "version": 1,
  "createdBy": "625d0c01a162fb2205cebc36",
  "lastUpdateBy": "625d0c01a162fb2205cebc36",
  "lastUpdatedOn": "2022-04-21T07:09:37.453Z",
  "definition": {
    "protocol": "none",
    "clientId": "",
    "strategy": "Default",
    "settings": {
      "loopback": true
    },
    "model": {
      "currentState": "Init",
      "stateMap": {
        "Init": {
          "name": "Init",
          "isEnabled": true,
          "sender": "{\n  /*\n  CHANGELOG\n\n\n  08-02-2022 \n  - Changed evalSchedule() to use dayjs instead of momentjs\n  - enabled REST operations\n  - Wrapped rest operations in try..catch\n   */\n  console.log(\n    `SEQINFO: In Init State - Client: ${client()} , Iteration: ${index()}`\n  );\n  state._$timestamp = new Date();\n  state.mailboxCleared = false;\n  let config = glob.get(\"config\");\n  state._$iterationConfig = config?.iterationConfig?.thermostat || [];\n  state.SPEED_CONSTANT = config?.iterationConfig?.SPEED_CONSTANT;\n\n  state._$nextExecution = {};\n  state.PAYLOADS = [];\n\n  state._$iterationConfig.forEach((obj) => {\n    obj.interval /= state.SPEED_CONSTANT;\n    state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n  });\n\n  if (client() === 0) {\n    let manualTrigger = {\n      fun: \"\",\n      count: 0,\n      spread: 1,\n    };\n    await glob.set(\"Thermostats_manualTrigger\", manualTrigger);\n    await glob.set(\"Thermostats_manualTriggerCount\", 0);\n\n  }\n\n  // state.thermostats = (await glob.get(\"G\" + client() + \"_thermostats\")) || {};\n  state.thermostats = {};\n  state.timeoutSent == false\n\n\n  next(\"Helpers\");\n  console.log(`SEQINFO: Completed Init State`);\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 0
        },
        "Finished": {
          "name": "Finished",
          "isEnabled": true,
          "sender": "\n{\n  console.log(`SEQINFO: In Helper State - Client: ${client()} , Iteration: ${index()}`)\n\n  glob.set(\"G\" + client() + \"_thermostats\", state.thermostats)\n\n  console.log(`SEQINFO: Completed Finished State`)\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 3
        },
        "Online": {
          "index": 2,
          "name": "Online",
          "isEnabled": true,
          "sender": "\n{\n  console.log(`SEQINFO: In Online State - Client: ${client()} , Iteration: ${index()}`)\n\n  state.activeThermostats = (await glob.get(\"G\" + client() + \"_ActiveThermostats\")) || {};\n  state._$timestamp = new Date();\n\n  if (!state.mailboxCleared) {\n    await state.helpers.clearMailbox(Object.keys(state.activeThermostats));\n    console.log(\"Mailbox successfully cleared upon start\");\n    state.mailboxCleared = true;\n  }\n\n\n  console.log(\"SEQINFO: Checking token\");\n  await state.helpers.checkToken();\n  await state.helpers.checkManualTrigger();\n\n\n  if (Object.keys(state.activeThermostats).length < Object.keys(state.thermostats).length) {\n    console.log(\"INFO : Thermostat(s) removed from gateway\");\n\n    await state.helpers.handleRemoveThermostat();\n  } else if (\n    Object.keys(state.activeThermostats).length > Object.keys(state.thermostats).length\n  ) {\n    console.log(\"INFO : New Thermostat added to gateway\");\n\n    await state.helpers.handleNewThermostat();\n  }\n\n  console.log(\"Thermostats in state : \", Object.keys(state.thermostats));\n\n  if (Object.keys(state.thermostats).length > 0) {\n    // try {\n    //   await state.helpers.checkScheduleId(Object.keys(state.thermostats))\n    // } catch (e) {\n    //   console.log(e)\n    // }\n    //try {\n    //  await state.helpers.updateState(Object.keys(state.thermostats))\n    //}\n    //catch (e) {\n    //  console.log(\"ERR: error updating state. \", e)\n    //}\n\n    Object.keys(state.activeThermostats).forEach(async (thing_name) => {\n      console.log(\"SEQINFO: Evaluating schedules\")\n      try {\n        await state.helpers.evalSchedule(thing_name);\n      } catch (e) {\n        console.log(\"ERR: error in evaluating schedulas\", e)\n      }\n    });\n    console.log(\"SEQINFO: Checking Rules\");\n    await state.helpers.checkRules(Object.keys(state.thermostats));\n\n    console.log(\"SEQINFO: Checking Incoming status\");\n    await state.helpers.checkIncomingCmd(Object.keys(state.thermostats));\n    \n    let timerS = Date.now();\n    console.log(\"SEQINFO: Checking Incoming messages\");\n    await state.helpers.checkIncoming(Object.keys(state.thermostats));\n    let timerE = Date.now();\n    metric.add(\"Thermostats_checkIncoming\", timerE - timerS);\n\n    console.log(\"SEQINFO: Running scheduled Payloads\");\n    try {\n      await state.helpers.handleScheduledPayloads(Object.keys(state.thermostats));\n    } catch (e) {\n      console.log(\"ERR: error in scheduled function\", e);\n    }\n  } else {\n    console.log(\"No Thermostats in state\");\n  }\n\n  // state.helpers.publish(\"ping\", \"hello\")\n\n  if (iteration() === jobRepeat() - 2) next(\"Finished\"); // Trigger state transition in penultimate iteration\n  console.log(`SEQINFO: Completed Online State`)\n}\n",
          "receiver": "{\n  metric.add('Thermostats_RHTriggered')\n  // console.log(\"RH recieved: \", JSON.stringify(response))\n  response = JSON.parse(response)\n  let { topic, res } = response;\n\n  // res = await JSON.parse(res)\n  if (!res?.state) return\n\n  state.activeContactSensors = (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n  let contactSensors = Object.keys(state.activeContactSensors)\n\n  state._$timestamp = new Date();\n\n  let thing_name = topic.split(\"/\")[2] || \"\";\n  console.log(\"Received Message for :\", thing_name);\n\n\n  if (topic === \"$aws/things/\" + thing_name + \"/shadow/update/delta\") {\n\n    \n\n    // console.log(\"Response: \" + response);\n    if (res && res.state && res.state.commands) {\n\n      let commands = res.state.commands\n      metric.add(\"Thermostats_deltaCommandRX\")\n\n      console.log(\"COMMANDS: \", commands);\n      let timestamps = Object.keys(commands)\n\n      timestamps.forEach((timestamp) => {\n        if (commands[timestamp].mode === \"heat\") {\n          state.thermostats[thing_name].setpoints = { heating_setpoint: commands[timestamp].setpoint }\n          state.thermostats[thing_name].mode = \"heat\"\n          state.thermostats[thing_name].cloudCommand = {\n            ...commands[timestamp],\n            heating_setpoint: commands[timestamp].setpoint,\n            source: \"cloud\"\n          }\n          delete state.thermostats[thing_name].cloudCommand.setpoint\n\n          // state._$queue.push({\n          //   fun: \"sendCloudSetpoints\"\n          // })\n\n          state.helpers.publish(state.thermostatFunctions.sendCloudSetpoints(thing_name), thing_name)\n        }\n\n        else if (commands[timestamp].mode === \"cool\") {\n          state.thermostats[thing_name].setpoints = { cooling_setpoint: commands[timestamp].setpoint }\n          state.thermostats[thing_name].mode = \"cool\"\n          state.thermostats[thing_name].cloudCommand = {\n            ...commands[timestamp],\n            cooling_setpoint: commands[timestamp].setpoint,\n            source: \"cloud\"\n          }\n          delete state.thermostats[thing_name].cloudCommand.setpoint\n\n          // state._$queue.push({\n          //   fun: \"sendCloudSetpoints\"\n          // })\n          state.helpers.publish(state.thermostatFunctions.sendCloudSetpoints(thing_name), thing_name)\n\n        }\n\n        else if (commands[timestamp].mode === \"off\") {\n          state.thermostats[thing_name].setpoints = {}\n          state.thermostats[thing_name].mode = \"off\"\n          state.thermostats[thing_name].cloudCommand = {\n            ...commands[timestamp],\n            source: \"cloud\"\n          }\n          // state._$queue.push({\n          //   fun: \"sendCloudSetpoints\"\n          // })\n          state.helpers.publish(state.thermostatFunctions.sendCloudSetpoints(thing_name), thing_name)\n\n        }\n\n        else if (!!commands[timestamp].heating_setpoint) {\n          state.thermostats[thing_name].setpoints = { heating_setpoint: commands[timestamp].heating_setpoint }\n          state.thermostats[thing_name].cloudCommand = {\n            ...commands[timestamp],\n            source: \"cloud\"\n          }\n          // state._$queue.push({\n          //   fun: \"sendCloudSetpoints\"\n          // })\n          state.helpers.publish(state.thermostatFunctions.sendCloudSetpoints(thing_name), thing_name)\n\n        }\n\n        else if (!!commands[timestamp].cooling_setpoint) {\n          state.thermostats[thing_name].setpoints = { cooling_setpoint: commands[timestamp].heating_setpoint }\n          state.thermostats[thing_name].cloudCommand = {\n            ...commands[timestamp],\n            source: \"cloud\"\n          }\n          // state._$queue.push({\n          //   fun: \"sendCloudSetpoints\"\n          // })\n          state.helpers.publish(state.thermostatFunctions.sendCloudSetpoints(thing_name), thing_name)\n\n        }\n\n        else if (commands[timestamp].mode === \"get_battery\") {\n\n          // state._$queue.push({\n          //   fun: \"sendBattery\"\n          // })\n          state.helpers.publish(state.thermostatFunctions.sendBattery(thing_name), thing_name)\n\n        }\n      });\n\n    }\n\n    if (res && res.state && res.state.settings && res.state.settings.schedule) {\n      let schedule = res.state.settings.schedule;\n      let scheduleId = schedule.split(\"|\")[0]\n\n      let urlGet =\n        \"https://keyless.rentlypt.com/api/schedules/\" +\n        scheduleId;\n      let optionsGet = {\n        headers: {\n          \"content-type\": \"application/json\",\n          Authorization: \"Bearer \" + state?.token?.apiToken,\n        },\n      };\n      try {\n        state.getRes = rest.get(urlGet, optionsGet);\n        // console.log(state.getRes)\n      } catch (e) {\n        console.error(e);\n      }\n\n      if (state?.getRes?.schedule_details_info) {\n        state.thermostats[thing_name].schedule_info = state?.getRes?.schedule_details_info;\n      } else {\n        console.error(\"No Schedule info returned \")\n      }\n      \n    };\n\n\n    // if (res && res.state && res.state.settings && res.state.settings.rule) {\n    //   state.rules = res.state.settings.rule;\n    //   console.log(\"Thermostat rules recieved\")\n    // };\n    \n\n    if (res && res.state) {\n\n      let x = {\n        state: {\n          reported: {\n            ...res.state,\n            thing_name,\n            updateTime: state._$timestamp.toISOString(),\n          },\n        },\n      };\n      // state.helpers.publish(x, thing_name);\n      // console.log(\"SEQINFO: Echo back sent\")\n    }\n    \n  }\n}"
        },
        "Helpers": {
          "index": 1,
          "name": "Helpers",
          "isEnabled": true,
          "sender": "{\n  state.activeContactSensors = (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n  let contactSensors = Object.keys(state.activeContactSensors)\n  \n  console.log(\n    `SEQINFO: In Helper State - Client: ${client()} , Iteration: ${index()}`\n  );\n  state.helpers = {};\n\n  state.helpers.checkToken = async function () {\n    if (\n      !state.token ||\n      state.token?.token_exp <= Math.floor(Date.now() / 1000)\n    ) {\n      state.token = await glob.get(\"APItoken\");\n    }\n  };\n\n  // state.helpers.checkScheduleId = async function (thing_names) {\n  //   console.log(\"SEQINFO: Checking schedule\")\n  //   thing_names.forEach(async (thing_name) => {\n  //     if (!state.thermostats[thing_name].schedules) {\n  //       scheduleId = await glob.get(\"thermostats_scheduleId\");\n  //       if (!scheduleId) {\n  //         console.error(\"No Schedule Set\");\n  //         if (client() === 0) {\n  //           await state.thermostatFunctions.triggerSetSchedule(thing_name);\n  //         }\n  //       }\n\n  //       state.thermostats[thing_name].schedules = scheduleId;\n  //       state.helpers.refreshSchedule(thing_name);\n  //       let x = state.thermostatFunctions.sendScheduleID(thing_name);\n  //       state.helpers.publish(x, thing_name);\n\n  //     }\n  //   });\n  // };\n\n  state.helpers.clearMailbox = async function (thing_names) {\n    console.log(\"SEQINFO: Clearing mailboxes for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      let count = mailbox.count(\"\" + thing_name + \"_rx\");\n      metric.add(\"Mailbox_size\", count);\n      mailbox.delete(\"\" + thing_name + \"_rx\");\n    });\n  };\n\n  state.helpers.checkIncoming = async function (thing_names) {\n    console.log(\"SEQINFO: Checking mailboxes for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      while (mailbox.count(\"\" + thing_name + \"_rx\") > 0) {\n        let msg = await mailbox.pop(\"\" + thing_name + \"_rx\");\n        msg.thing_name = thing_name;\n        await protocol.sendPayload(msg);\n      }\n    });\n  };\n\n  state.helpers.checkRules = async function (thing_names) {\n    console.log(\"SEQINFO: Checking rules for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      if (state.rules) {\n        let ruleIds = Object.keys(state.rules)\n\n        var ruleMsgTS = {}\n\n        ruleIds.forEach(async (rule) => {\n          if (rule == \"3\") {\n            console.log(\"Rule 3 check\")\n            let heating_limit = state.rules[rule][1].heat\n            let cooling_limit = state.rules[rule][1].cool\n\n            if (state.thermostats[thing_name]?.setpoints?.heating_setpoint > heating_limit) {\n              console.log(\"Rule 3: Heating limit breached\")\n\n              ruleMsgTS = {\n                message: {\n                  \"[ACRangeRule]\":\n                    \"{ Rule broke }  (heating set-point) \" + state.thermostats[thing_name].setpoints.heating_setpoint + \" is above <Highest_heat_set-point> \" + heating_limit + \" <Adjusted-Settings> (heating set-point) \" + heating_limit\n                }\n              }\n              state.thermostats[thing_name].setpoints.heating_setpoint = heating_limit;\n              state.thermostats[thing_name].source = \"rule\"\n\n              let update = {\n                state: {\n                  reported: {\n                    thing_name,\n                    notification: {\n                      message: ruleMsgTS\n                    },\n                    updateTime: state._$timestamp.toISOString(),\n                  }\n                }\n              }\n\n              await state.helpers.publish(update, thing_name);\n\n              let x = state.thermostatFunctions.sendSetpoints(thing_name);\n              state.helpers.publish(x, thing_name);\n            }\n\n            else if (state.thermostats[thing_name]?.setpoints?.cooling_setpoint < cooling_limit) {\n              console.log(\"Rule 3: Cooling limit breached\")\n\n              ruleMsgTS = {\n                message: {\n                  \"[ACRangeRule]\":\n                    \"{ Rule broke }  (cooling set-point) \" + state.thermostats[thing_name].setpoints.cooling_setpoint + \" is below  <Lowest_cool_set-point> \" + cooling_limit + \" <Adjusted-Settings> (cooling set-point) \" + cooling_limit\n                }\n              }\n              state.thermostats[thing_name].setpoints.cooling_setpoint = cooling_limit;\n              state.thermostats[thing_name].source = \"rule\"\n\n              let update = {\n                state: {\n                  reported: {\n                    thing_name,\n                    notification: {\n                      message: ruleMsgTS\n                    },\n                    updateTime: state._$timestamp.toISOString(),\n                  }\n                }\n              }\n\n              await state.helpers.publish(update, thing_name);\n\n              let x = state.thermostatFunctions.sendSetpoints(thing_name);\n              state.helpers.publish(x, thing_name);\n            }\n\n\n          }\n\n          else if (rule == 4) {\n            console.log(\"Rule 4 check\")\n\n            let heating_limit = state.rules[rule][1].heat\n\n            if (state.thermostats[thing_name]?.setpoints?.heating_setpoint < heating_limit) {\n              console.log(\"Rule 4: Heating limit breached\")\n\n              ruleMsgTS = {\n                message: {\n                  \"[FrostPreventionRule]\":\n                    \"{ Rule broke }  (cooling set-point) \" + state.thermostats[thing_name].setpoints.heating_setpoint + \" is below  <Lowest_cool_set-point> \" + heating_limit + \" <Adjusted-Settings> (cooling set-point) \" + heating_limit\n                }\n              }\n              state.thermostats[thing_name].mode = \"heat\",\n              state.thermostats[thing_name].setpoints.heating_setpoint = heating_limit;\n              state.thermostats[thing_name].source = \"rule\"\n\n              let update = {\n                state: {\n                  reported: {\n                    thing_name,\n                    notification: {\n                      message: ruleMsgTS\n                    },\n                    updateTime: state._$timestamp.toISOString(),\n                  }\n                }\n              }\n\n              await state.helpers.publish(update, thing_name);\n\n              let x = state.thermostatFunctions.sendSetpoints(thing_name);\n              state.helpers.publish(x, thing_name);\n            }\n\n\n          }\n          else if (rule == 5) {\n            console.log(\"Rule 5 check\")\n\n            let cooling_limit = state.rules[rule][1].cool\n\n            if (state.thermostats[thing_name]?.setpoints?.cooling_setpoint > cooling_limit) {\n              console.log(\"Rule 5: Temperature limit breached\")\n\n              ruleMsgTS = {\n                message: {\n                  \"[HeatPreventionRule]\":\n                    \"{ Rule broke }  (room temperature) \" + state.thermostats[thing_name].setpoints.cooling_setpoint + \" is above  <Heat_prevention_temperature> \" + cooling_limit + \" <Adjusted-Settings> (cooling set-point) \" + cooling_limit + \"(mode) COOL\"\n                }\n              }\n              state.thermostats[thing_name].mode = \"cool\",\n              state.thermostats[thing_name].setpoints.cooling_setpoint = cooling_limit;\n              state.thermostats[thing_name].source = \"rule\"\n\n              let update = {\n                state: {\n                  reported: {\n                    thing_name,\n                    notification: {\n                      message: ruleMsgTS\n                    },\n                    updateTime: state._$timestamp.toISOString(),\n                  }\n                }\n              }\n\n              await state.helpers.publish(update, thing_name);\n\n              let x = state.thermostatFunctions.sendSetpoints(thing_name);\n              state.helpers.publish(x, thing_name);\n              let y = state.thermostatFunctions.sendMode(thing_name);\n              state.helpers.publish(y, thing_name);\n            }\n          }\n\n          /*else if (rule == 5) {\n            console.log(\"Rule 5 check\")\n\n            let cooling_limit = state.rules[rule][1].cool\n            let humidity_limit = state.rules[rule][1].humidity\n\n            if (state.thermostats[thing_name]?.temperature  > cooling_limit) {\n              console.log(\"Rule 5: Temperature limit breached\")\n\n              ruleMsgTS = {\n                message: {\n                  \"[HeatPreventionRule]\":\n                    \"{ Rule broke }  (room temperature) \" + state.thermostats[thing_name].temperature  + \" is above  <Heat_prevention_temperature> \" + cooling_limit + \" <Adjusted-Settings> (cooling set-point) \" + cooling_limit + \"(mode) COOL\"\n                }\n              }\n              state.thermostats[thing_name].mode = \"cool\";\n              state.thermostats[thing_name].setpoints.cooling_setpoint = cooling_limit;\n              state.thermostats[thing_name].source = \"rule\"\n\n              let update = {\n                state: {\n                  reported: {\n                    thing_name,\n                    notification: {\n                      message: ruleMsgTS\n                    },\n                    updateTime: state._$timestamp.toISOString(),\n                  }\n                }\n              }\n\n              await state.helpers.publish(update, thing_name);\n\n              let x = state.thermostatFunctions.sendSetpoints(thing_name);\n              state.helpers.publish(x, thing_name);\n            }\n\n          }*/\n\n          else if (rule == 10) {\n            console.log(\"Rule 10 check\");\n\n            let cs_timeout = state.rules[rule][1].timeout\n\n            contactSensors.forEach(async (contactSensor) => {\n              let timeout = cs_timeout\n              let thermostat = thing_name\n              if (state.timeoutSent == false) {\n                console.log(\"Rule 10 execcuted\")\n                mailbox.post(\"\" + contactSensor + \"_cmd\", { thermostat, timeout });\n                state.timeoutSent = true;\n              }\n              // mailbox.post(\"\" + contactSensor + \"_cmd\", { thermostat, timeout });\n            })\n          }\n        })\n      }\n      else {\n        console.log(\"No rules set\")\n      }\n\n    })\n\n\n\n  };\n\n  state.helpers.checkIncomingCmd = async function (thing_names) {\n    console.log(\"SEQINFO: Checking commands for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      while (mailbox.count(\"\" + thing_name + \"_cmd\") > 0) {\n        let msg = await mailbox.pop(\"\" + thing_name + \"_cmd\");\n        console.log(msg)\n\n        if (msg.trigger) {\n\n          console.log(\"Received timeout error from CS; Thermostat is: \" + state.thermostats[thing_name].mode)\n          if (state.thermostats[thing_name].mode != \"off\") {\n            console.log(\"Recived timeout error from CS; Thermostat is not off, sending Rule Broke message\")\n            state.modeBeforeAlert = state.thermostats[thing_name].mode;\n\n            let ruleMsgCS = {\n              message: {\n                \"[ContactSensorRule]\":\n                  \"{ Rule broke } (mode) \" + state.thermostats[thing_name].mode + \" (mode) should be  OFF\"\n              }\n            }\n\n            let update = {\n              state: {\n                reported: {\n                  thing_name,\n                  notification: {\n                    message: ruleMsgCS\n                  },\n                  updateTime: state._$timestamp.toISOString(),\n                }\n              }\n            }\n\n            await state.helpers.publish(update, thing_name);\n\n            state.thermostats[thing_name].mode = \"off\"\n            state.thermostats[thing_name].source = \"rule\"\n\n            let x = state.thermostatFunctions.sendMode(thing_name);\n            state.helpers.publish(x, thing_name);\n          }\n        }\n        else if (msg.gateway) {\n          state.rules = msg.rules;\n          console.log(\"Thermostat rules recieved\", state.rules)\n          state.timeoutSent = false\n        }\n        else if (msg.contactClosed) {\n          console.log(\"Received Closed status from CS; Thermostat is going back to previous mode\")\n\n          state.thermostats[thing_name].mode = state.modeBeforeAlert\n          state.thermostats[thing_name].source = \"rule\"\n\n          let x = state.thermostatFunctions.sendMode(thing_name);\n          state.helpers.publish(x, thing_name);\n        }\n      }\n    });\n  };\n\n  state.helpers.checkManualTrigger = async function () {\n    let manualTrigger = await glob.get(\"Thermostats_manualTrigger\");\n\n    if (manualTrigger.count > state.localManualTriggerCount) {\n      console.log(\"INFO: Received Manual Trigger for \" + manualTrigger.fun);\n\n      let check = state._$iterationConfig.find(\n        (o) => o.fun === manualTrigger.fun\n      );\n\n      if (!check) {\n        console.log(\n          \"ERR: Invalid Manual Trigger. Function doesn't exist in iterationConfig.\"\n        );\n        return false;\n      } else {\n        state.pendingManualTriggerFunction = manualTrigger.fun;\n        state.startIteration = index() + 1;\n\n        state.clientBatch = Math.ceil(jobClients() / manualTrigger.spread);\n        ++state.localManualTriggerCount;\n        console.log(\"INFO: Set Pending Manual Trigger to \" + manualTrigger.fun);\n        // glob.incr(\"manualTriggerCount\",1);\n        metric.add(\"Thermostats_pendingManualTrigger\");\n      }\n    } else {\n      // state.manualTriggerFunction = \"\";\n    }\n    if (\n      !!state.pendingManualTriggerFunction &&\n      Math.floor(client() / state.clientBatch) == index() - state.startIteration\n    ) {\n      state.manualTriggerFunction = state.pendingManualTriggerFunction;\n      state.pendingManualTriggerFunction = false;\n      console.log(\n        \"INFO: Set State Manual Trigger to \" + state.manualTriggerFunction\n      );\n      glob.incr(\"Thermostats_manualTriggerCount\", 1);\n      metric.add(\"Thermostats_manualTrigger\");\n    } else {\n      state.manualTriggerFunction = \"\";\n    }\n  };\n\n  state.helpers.updateState = async function (thing_names) {\n    console.log(\"SEQINFO: Checking state for: \", thing_names);\n    thing_names.forEach(async (thing_name) => {\n      if (!state.thermostats[thing_name].mode) {\n        await state.helpers.randomMode(thing_name);\n      }\n\n      if (\n        state.thermostats[thing_name].schedules &&\n        !state.thermostats[thing_name].schedule_info\n      ) {\n        state.helpers.refreshSchedule(thing_name);\n      }\n      await state.helpers.evalSchedule(thing_name);\n    });\n  };\n\n  state.helpers.publish = async function (payload, thing_name) {\n    if (!payload?.state) {\n      console.error(\"Skipped publishing message that contains no state\")\n      return false\n    }\n    //Added zwave_signal check\n    else if (state?.thermostats[thing_name]?.zwave_signal <= 0) {\n      console.error(\"Skipped publishing since Zwave_signal was 0 or -1 \")\n      return false\n    }\n\n    \n    let msg = {\n      payload,\n      topic: \"$aws/things/\" + thing_name + \"/shadow/update\",\n    };\n\n    // state.PAYLOADS.push(payload);\n    await mailbox.post(\"Gateway_\" + client() + \"_tx\", msg);\n  };\n\n  state.helpers.handleRemoveThermostat = async function () {\n    let removeThermostats = _.difference(\n      Object.keys(state.thermostats),\n      Object.keys(state.activeThermostats)\n    );\n\n    console.log(\"INFO: Removing Thermostats \", removeThermostats);\n\n    removeThermostats.forEach(async (thing_name) => {\n      metric.add(\"Thermostats_removeThermostat\", 1);\n      try {\n        delete state.thermostats[thing_name];\n        console.log(\"Removed \", thing_name);\n      } catch (e) {\n        console.log(\"ERR: Failed to remove thermostat \", e);\n      }\n    });\n\n    console.log(\n      \"INFO: Simulation now running for thermostats : \",\n      state.thermostats\n    );\n  };\n\n  state.helpers.handleNewThermostat = async function () {\n    Object.keys(state.activeThermostats).forEach(async (thing_name) => {\n      if (!Object.keys(state.thermostats).includes(thing_name)) {\n        console.log(\"INFO: Found New Thermostat : \", thing_name);\n        metric.add(\"Thermostats_newThermostat\", 1);\n        state.thermostats[thing_name] = state.activeThermostats[thing_name];\n        await state.helpers.initThermostat(thing_name);\n      } else {\n        console.log(`${thing_name} already exists in state`);\n      }\n    });\n\n    console.log(\n      \"INFO: Simulation running for thermostats : \",\n      state.thermostats\n    );\n  };\n\n  state.helpers.initThermostat = async function (thing_name) {\n    metric.add(\"Thermostats_initThermostat\", 1);\n    console.log(\"SEQINFO: Intializing thermostat : \", thing_name);\n\n    state.helpers.randomMode(thing_name);\n    \n    let x = state.thermostatFunctions.sendRoomTemp(thing_name);\n    await state.helpers.publish(x, thing_name);\n    metric.add(\"Thermostats_sendRoomTemp\", 1);\n    x = state.thermostatFunctions.sendMode(thing_name);\n    await state.helpers.publish(x, thing_name);\n    metric.add(\"Thermostats_sendMode\", 1);\n/*\n     x = state.thermostatFunctions.sendRoomHumidity(thing_name);\n     await state.helpers.publish(x, thing_name);\n     metric.add(\"Thermostats_sendRoomHumidity\", 1);\n\n    \n\n    x = state.thermostatFunctions.sendOperatingState(thing_name);\n    await state.helpers.publish(x, thing_name);\n    metric.add(\"Thermostats_sendOperatingState\", 1);\n\n    x = state.thermostatFunctions.sendConnStatus(thing_name);\n    await state.helpers.publish(x, thing_name);\n    metric.add(\"Thermostats_sendConnStatus\", 1);\n\n    x = state.thermostatFunctions.sendPowerSource(thing_name);\n    await state.helpers.publish(x, thing_name);\n    metric.add(\"Thermostats_sendPowerSource\", 1);\n\n    x = state.thermostatFunctions.sendSetpoints(thing_name);\n    await state.helpers.publish(x, thing_name);\n     metric.add(\"Thermostats_sendSetpoints\", 1);\n    */\n\n    // if (client() === 0 && Object.keys(state.thermostats).length === 1) {\n    // await state.thermostatFunctions.triggerSetSchedule(thing_name);\n    // }\n  };\n\n  state.helpers.handleScheduledPayloads = async function (thing_names) {\n    state._$iterationConfig.forEach(async (obj) => {\n      if (\n        Date.now() >= state._$nextExecution[obj.fun] ||\n        obj.fun === state?.manualTriggerFunction\n      ) {\n        state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n\n        console.log(\"TRIGGER: \", obj.fun);\n        thing_names.forEach(async (thing_name) => {\n          state.helpers.publish(\n            state.thermostatFunctions[obj.fun](thing_name),\n            thing_name\n          );\n        });\n      }\n    });\n  };\n\n  state.helpers.randomMode = async function (thing_name) {\n    state.thermostats[thing_name].mode = chance.pickone([\n      \"cool\",\n      \"heat\",\n      \"off\",\n      \"auto\",\n      \"aux\",\n    ]);\n    if (state.thermostats[thing_name].mode === \"cool\") {\n      state.thermostats[thing_name].operating_state = chance.pickone([\n        \"cool\",\n        \"pending_cool\",\n        \"off\",\n      ]);\n      state.thermostats[thing_name].setpoints = {\n        cooling_setpoint: chance.integer({\n          min: 50,\n          max: 100,\n        }),\n      };\n    } else if (state.thermostats[thing_name].mode === \"heat\" || \"aux\") {\n      state.thermostats[thing_name].operating_state = chance.pickone([\n        \"heat\",\n        \"pending_heat\",\n        \"off\",\n      ]);\n      state.thermostats[thing_name].setpoints = {\n        heating_setpoint: chance.integer({\n          min: 50,\n          max: 100,\n        }),\n      };\n    } else if (state.thermostats[thing_name].mode === \"off\") {\n      state.thermostats[thing_name].operating_state = \"off\";\n      state.thermostats[thing_name].setpoints = \"\";\n    } else {\n      state.thermostats[thing_name].operating_state = chance.pickone([\n        \"cool\",\n        \"heat\",\n        \"pending_cool\",\n        \"pending_heat\",\n        \"off\",\n      ]);\n      var random = chance.integer({\n        min: 1,\n        max: 10,\n      });\n      if (random <= 5) {\n        state.thermostats[thing_name].setpoints = {\n          cooling_setpoint: chance.integer({\n            min: 50,\n            max: 100,\n          }),\n        };\n      } else {\n        state.thermostats[thing_name].setpoints = {\n          heating_setpoint: chance.integer({\n            min: 50,\n            max: 100,\n          }),\n        };\n      }\n    }\n  };\n\n  state.helpers.setSchedule = async function (thing_name) {\n    let thermostatId = thing_name.substring(thing_name.indexOf(\"-\") + 1);\n\n    let obj = {};\n\n    obj = {\n      schedule_details_info: [\n        {\n          d: \"1\",\n          f: \"01:45\",\n          m: \"auto\",\n          fan: \"on\",\n          h: \"60\",\n          c: \"70\",\n        },\n        {\n          d: \"1\",\n          f: \"01:50\",\n          fan: \"on\",\n          m: \"cool\",\n          v: \"75\",\n        },\n        {\n          d: \"1\",\n          f: \"01:55\",\n          fan: \"on\",\n          m: \"heat\",\n          v: \"110\",\n        },\n        {\n          d: \"1\",\n          f: \"02:00\",\n          fan: \"on\",\n          m: \"off\",\n        },\n      ],\n      schedule_name:\n        \"V2_Validation_try_2\" + chance.integer({ min: 100, max: 1000000 }),\n      device_type: \"thermostat\",\n    };\n    let url =\n      \"https://keyless.rentlypt.com/api/devices/\" +\n      thermostatId +\n      \"/schedules\";\n\n    let options = {\n      headers: {\n        \"content-type\": \"application/json\",\n        Authorization: \"Bearer \" + state?.token?.apiToken,\n      },\n    };\n\n    console.log(\"Sending Set Schedule Request to: \", url);\n\n    try {\n      state.scheduleRes = rest.post(url, obj, options);\n    } catch (e) {\n      console.error(e);\n    }\n\n    // state.scheduleRes = {}\n    console.log(\"Received Set Schedule Response: \", state.scheduleRes);\n\n    if (state.scheduleRes?.success) {\n      state.thermostats[thing_name].schedules = state.scheduleRes.id;\n      // await glob.set(\"thermostats_scheduleId\", state.scheduleRes.id);\n    } else {\n      //assert(false, \"Failed to set code\");\n    }\n    state.schedule = false;\n    // \t\tsendScheduleID();\n    // state._$queue.push({\n    //   fun: \"sendScheduleID\",\n    // });\n    let x = state.thermostatFunctions.sendScheduleID(thing_name);\n    state.helpers.publish(x, thing_name);\n    // state.refreshSchedule = true;\n    state.helpers.refreshSchedule(thing_name);\n  };\n\n  state.helpers.refreshSchedule = async function (thing_name) {\n    console.log(\n      \"Fetching schedule ID: \" + state.thermostats[thing_name].schedules\n    );\n    let url =\n      \"https://keyless.rentlypt.com/api/schedules/\" +\n      state.thermostats[thing_name].schedules;\n    let options = {\n      headers: {\n        Authorization: \"Bearer \" + state?.token?.apiToken,\n      },\n    };\n\n    try {\n      state.getScheduleRes = rest.get(url, options);\n    } catch (e) {\n      console.error(e);\n    }\n\n    // state.getScheduleRes = {}\n\n    if (state?.getScheduleRes?.schedule_details_info) {\n      state.thermostats[thing_name].schedule_info = state?.getScheduleRes?.schedule_details_info;\n    } else {\n      console.error(\"No Schedule info returned \")\n    }\n\n    \n    state.refreshSchedule = false;\n  };\n\n  state.helpers.evalSchedule = async function (thing_name) {\n    _.each(state.thermostats[thing_name].schedule_info, function (entry) {\n      if (entry.eval === true) {\n        console.log(\"Entry already evaluated\");\n      } else {\n        var day = dayjs().day();\n        current_time = dayjs().tz(\"Asia/Kolkata\");\n\n        //Compare current day with schedule day\n        //check if not started\n        if (day == entry.d) {\n          scheduled_time = dayjs(entry.f, \"HH:mm\")\n          console.log(\"There's a schedule for today \" + entry.d + \" scheduled at\" + scheduled_time.format(\"HH:mm\"));\n          // console.log(\"Current Time: \" + current_time + \", Scheduled Time: \" + scheduled_time)\n\n          //Compare current time with schedule time\n          if (current_time.format(\"HH:mm\") == scheduled_time.format(\"HH:mm\")) {\n            console.log(\"Current time same as sched time\");\n            state.thermostats[thing_name].source = \"schedule\";\n            state.thermostats[thing_name].mode = entry.m;\n            console.log(entry);\n            //If mode is available in schedule\n            if (entry.m === \"cool\") {\n              state.thermostats[thing_name].setpoints = {};\n              state.thermostats[thing_name].setpoints = {\n                cooling_setpoint: entry.v,\n              };\n              entry.eval = true;\n            } else if (entry.m === \"heat\") {\n              state.thermostats[thing_name].setpoints = {};\n              state.thermostats[thing_name].setpoints = {\n                heating_setpoint: entry.v,\n              };\n              entry.eval = true;\n            } else if (entry.m === \"off\") {\n              state.thermostats[thing_name].setpoints = {};\n              entry.eval = true;\n            } else if (entry.m === \"auto\") {\n              state.thermostats[thing_name].setpoints = {\n                heating_setpoint: entry.h,\n                cooling_setpoint: entry.c,\n              };\n              entry.eval = true;\n            }\n            state.randomMode = false;\n            // state._$queue.push({\n            //   fun: \"sendMode\"\n            // }, {\n            //   fun: \"sendSetpoints\"\n            // })\n            let x = state.thermostatFunctions.sendMode(thing_name);\n            state.helpers.publish(x, thing_name);\n\n            x = state.thermostatFunctions.sendSetpoints(thing_name);\n            state.helpers.publish(x, thing_name);\n          }\n        }\n      }\n    });\n  };\n\n  state.helpers.deleteSchedule = async function (thing_name) {\n    let thermostatId = thing_name.substring(thing_name.indexOf(\"-\") + 1);\n\n    let urlGet =\n      \"https://keyless.rentlypt.com/api/devices/\" +\n      thermostatId +\n      \"/schedules/\";\n    let optionsGet = {\n      headers: {\n        \"content-type\": \"application/json\",\n        Authorization: \"Bearer \" + state?.token?.apiToken,\n      },\n    };\n    try {\n      state.getRes = rest.get(urlGet, optionsGet);\n    } catch (e) {\n      console.error(e);\n    }\n    // state.optionsGet = optionsGet;\n    // state.getRes = {};\n\n    let urlDel =\n      \"https://keyless.rentlypt.com/api/devices/\" +\n      thermostatId +\n      \"/schedules/\" +\n      state.thermostats[thing_name].schedules;\n\n    let optionsDelete = {\n      headers: {\n        Authorization: \"Bearer \" + state?.token?.apiToken,\n      },\n    };\n\n    try {\n      state.deleteRes = rest.delete(urlDel, {}, optionsDelete);\n    } catch (e) {\n      console.error(e);\n    }\n\n    // state.deleteRes = {}\n    state.thermostats[thing_name].schedule_info = false;\n  };\n  let thermostatFunctions = {};\n\n  thermostatFunctions.sendRoomTemp = function (thing_name) {\n    state.thermostats[thing_name].temperature = chance.integer({\n      min: 40,\n      max: 120,\n    });\n\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            room_temp: state.thermostats[thing_name].temperature,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.sendRoomHumidity = function (thing_name) {\n    state.thermostats[thing_name].humidity = chance.integer({\n      min: 20,\n      max: 100,\n    });\n\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          notification: {\n            room_humidity: state.thermostats[thing_name].humidity,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.sendMode = function (thing_name) {\n    //Current Mode\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            mode: state.thermostats[thing_name].mode,\n            source: state.thermostats[thing_name]?.source,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.sendOperatingState = function (thing_name) {\n    //Operating Mode\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            operating_state: state.thermostats[thing_name].operating_state,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.sendConnStatus = function (thing_name) {\n    state.thermostats[thing_name].zwave_signal = chance.integer({\n      min: -1,\n      max: 5,\n    });\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            zwave_signal: state.thermostats[thing_name].zwave_signal,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.sendBattery = function (thing_name) {\n    if (!state.thermostats[thing_name].battery) {\n      state.thermostats[thing_name].battery = chance.integer({\n        min: 1,\n        max: 100,\n      });\n    }\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            battery: state.thermostats[thing_name].battery,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.sendPowerSource = function (thing_name) {\n    state.thermostats[thing_name].power_source = chance.pickone([\n      \"main\",\n      \"battery\",\n      \"unknown\",\n    ]);\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            power_source: state.thermostats[thing_name].power_source,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    if (state.thermostats[thing_name].power_source === \"battery\") {\n      // let obj = {\n      //   fun: \"sendBattery\",\n      // };\n      // state._$queue.push(obj);\n      let x = state.thermostatFunctions.sendBattery(thing_name);\n      state.helpers.publish(x, thing_name);\n    }\n    return res;\n  };\n\n  thermostatFunctions.sendSetpoints = function (thing_name) {\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: {\n            ...state.thermostats[thing_name].setpoints,\n            source: state.thermostats[thing_name]?.source,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    if (state.thermostats[thing_name].source === \"schedule\")\n      delete state.thermostats[thing_name].source;\n    return res;\n  };\n\n  thermostatFunctions.sendScheduleID = function (thing_name) {\n    //Set Status\n    state.helpers.deleteSchedule(thing_name);\n    res = {\n      state: {\n        settings: {\n          schedule: state.thermostats[thing_name].schedules,\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.sendCloudSetpoints = function (thing_name) {\n    res = {\n      state: {\n        reported: {\n          thing_name,\n          status: state.thermostats[thing_name].cloudCommand,\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  thermostatFunctions.triggerSetSchedule = function (thing_name) {\n    // state.schedule = \"set\";\n    state.helpers.setSchedule(thing_name);\n    return {};\n  };\n  thermostatFunctions.triggerDeleteSchedule = function (thing_name) {\n    // state.delete = true;\n    state.helpers.deleteSchedule(thing_name);\n    return {};\n  };\n  thermostatFunctions.sendReported = function (thing_name) {\n    let res = {\n      state: {\n        reported: {\n          ...state._$deltaState,\n          thing_name,\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    return res;\n  };\n\n  state.thermostatFunctions = thermostatFunctions;\n\n  next(\"Online\");\n  console.log(`SEQINFO: Completed Helper State`);\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        }
      },
      "setup": "",
      "teardown": ""
    },
    "additionalPackages": {
      "utc": {
        "type": "npm",
        "content": "dayjs-plugin-utc",
        "name": "utc"
      },
      "timezone": {
        "type": "npm",
        "content": "dayjs-timezone-iana-plugin",
        "name": "timezone"
      }
    }
  },
  "history": [
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-18T06:59:26.214Z",
      "description": {
        "action": "Create"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-21T07:09:37.453Z",
      "description": {
        "action": "update"
      }
    }
  ]
}