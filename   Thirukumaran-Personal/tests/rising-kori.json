{
  "id": "6262a853a162fb2205cebff9",
  "name": "rising-kori",
  "workspaceId": "625d0bf0a162fb2205cebc28",
  "version": 1,
  "createdBy": "625d0c01a162fb2205cebc36",
  "lastUpdateBy": "625d0c01a162fb2205cebc36",
  "lastUpdatedOn": "2022-04-25T10:58:35.013Z",
  "definition": {
    "protocol": "mqtt",
    "clientId": "",
    "strategy": "Default",
    "settings": {
      "url": "mqtts://a3cs3g754w2d11.iot.us-east-1.amazonaws.com:8883",
      "timeout": 60000,
      "keepalive": 60000,
      "qos": 0,
      "reconnectPeriod": 60000,
      "connectTimeout": 120000,
      "retain": false,
      "topic": "$aws/things/{{state.pubTopic}}",
      "subscriptionTopics": [
        "$aws/things/{{state._$gateway.thingName}}/#"
      ],
      "key": "{{state._$key}}",
      "cert": "{{state._$cert}}",
      "ca": "-----BEGIN CERTIFICATE-----\nMIIE0zCCA7ugAwIBAgIQGNrRniZ96LtKIVjNzGs7SjANBgkqhkiG9w0BAQUFADCB\nyjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\nExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJp\nU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxW\nZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0\naG9yaXR5IC0gRzUwHhcNMDYxMTA4MDAwMDAwWhcNMzYwNzE2MjM1OTU5WjCByjEL\nMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZW\nZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJpU2ln\nbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp\nU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9y\naXR5IC0gRzUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1\nnmAMqudLO07cfLw8RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKzj/i5Vbex\nt0uz/o9+B1fs70PbZmIVYc9gDaTY3vjgw2IIPVQT60nKWVSFJuUrjxuf6/WhkcIz\nSdhDY2pSS9KP6HBRTdGJaXvHcPaz3BJ023tdS1bTlr8Vd6Gw9KIl8q8ckmcY5fQG\nBO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9r911kTMZHRxAy3QkGSGT2RT+\nrCpSx4/VBEnkjWNHiDxpg8v+R70rfk/Fla4OndTRQ8Bnc+MUCH7lP59zuDMKz10/\nNIeWiu5T6CUVAgMBAAGjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E\nBAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAH\nBgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVy\naXNpZ24uY29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFH/TZafC3ey78DAJ80M5+gKv\nMzEzMA0GCSqGSIb3DQEBBQUAA4IBAQCTJEowX2LP2BqYLz3q3JktvXf2pXkiOOzE\np6B4Eq1iDkVwZMXnl2YtmAl+X6/WzChl8gGqCBpH3vn5fJJaCGkgDdk+bW48DW7Y\n5gaRQBi5+MHt39tBquCWIMnNZBU4gcmU7qKEKQsTb47bDN0lAtukixlE0kF6BWlK\nWE9gyn6CagsCqiUXObXbf+eEZSqVir2G3l6BFoMtEMze/aiCKm0oHw0LxOXnGiYZ\n4fQRbxC1lfznQgUy286dUV4otp6F01vvpX1FQHKOtw5rDgb7MzVIcbidJ4vEZV8N\nhnacRHr2lVz2XTIIM6RUthg/aFzyQkqFOFSDX9HoLPKsEdao7WNq\n-----END CERTIFICATE-----",
      "username": "",
      "password": ""
    },
    "model": {
      "currentState": "Init",
      "stateMap": {
        "Helpers": {
          "index": 1,
          "name": "Helpers",
          "isEnabled": true,
          "sender": "{\n  let hubFunctions = {};\n  const fwVer = [\"2.7.5.0\",\"2.7.5.0\"]; // TODO: change these to const\n  const curr_conn_type = [\"wifi\", \"cellular\", \"ethernet\"];\n  const board_type = [\"V2\", \"V3\", \"V4\"];\n  const model = [\"sim7500a\", \"sim5300a\"];\n  const time_zone = [\n    \"Asia/Kolkata\",\n    \"Asia/Japan\",\n    \"Asia/Bangladesh\",\n    \"Asia/Korea\",\n    \"Asia/China\",\n  ];\n  const lock_models = [\n    \"540-25419-20556\",\n    \"297-32780-3840\",\n    \"297-32770-4096\",\n    \"297-32770-5632\",\n    \"297-32772-1536\",\n    \"297-32771-2816\",\n    \"297-32769-2816\",\n    \"297-32770-1536\",\n    \"297-32779-3840\",\n    \"297-64155-48896\",\n    \"297-3-1033\",\n    \"297-2-0\",\n    \"297-1-1033\",\n    \"144-1-1\",\n    \"59-25409-20548\",\n    \"297-4-2048\",\n    \"297-2-2048\",\n    \"297-4-521\",\n    \"297-32827-1288\",\n    \"144-3-568\",\n    \"144-2065-5032\",\n    \"541-259-3\",\n    \"297-32826-1288\",\n  ];\n  const thermostat_models = [\n    \"351-1540-20737\",\n    \"21076-512-33136\",\n    \"16-20563-12849\",\n    \"57-17-1\",\n    \"335-21570-21559\",\n    \"335-21570-21558\",\n    \"335-21570-21553\",\n    \"400-1-1\",\n    \"275-17750-21556\",\n    \"152-25601-263\",\n    \"152-51201-36\",\n    \"155-21332-23089\",\n    \"41366-99f5f9e6-d181\",\n    \"57-17-8\",\n  ];\n  const contactsensor_models = [\n    \"330-4-2\",\n    \"134-258-120\",\n    \"410-3-3\",\n    \"600-3-130\",\n    \"330-1-2\",\n    \"600-32-1794\",\n    \"881-258-187\",\n  ];\n  const motionsensor_models = [\n    \"600-256-4145\t\",\n    \"305-4-4387\",\n    \"271-2049-8194\",\n    \"12-513-9\",\n    \"600-3-141\",\n  ];\n  const siren_models = [\"600-256-4136\", \"881-259-164\", \"600-3-136\"];\n  // const shared = {\n  //   LockMACs: [\"\"],\n  // };\n  let shared = glob.get(\"sharedMac\");\n\n  hubFunctions.heartBeat = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: {\n            heartBeat: state._$timestamp.toISOString(),\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendFWver = async function () {\n    state._$gateway.firmware = { fwVer: chance.pickone(fwVer) };\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: state._$gateway.firmware,\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.hubPower = async function () {\n    let powerArr = [];\n\n    if (state._$gateway.power.status === \"unplugged\") {\n      powerArr.push(\"0x01\");\n      powerArr.push(state._$gateway.power.level);\n    } else {\n      powerArr.push(\"0xc1\");\n      powerArr.push(100);\n    }\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            powerNotification: powerArr,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.addDevice = async function () {\n    let deviceType = state.deletedDevice;\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    switch (deletedDevice) {\n      case \"thermostat\":\n        model = chance.pickone(thermostat_models);\n        console.log(\"Adding thermostat removed in last iteration\");\n        break;\n      case \"lock\":\n        model = chance.pickone(lock_models);\n        console.log(\"Adding lock removed in last iteration\");\n        break;\n      case \"motion_sensor\":\n        model = chance.pickone(motionsensor_models);\n        console.log(\"Adding motion sensor removed in last iteration\");\n        break;\n      case \"contact_sensor\":\n        model = chance.pickone(contactsensor_models);\n        console.log(\"Adding contact sensor removed in last iteration\");\n        break;\n      case \"siren\":\n        model = chance.pickone(siren_models);\n        console.log(\"Adding siren removed in last iteration\");\n        break;\n      default:\n        model = model = chance.pickone(lock_models);\n        console.log(\"Couldn't find device type, adding lock\");\n        break;\n    }\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.addThermostat = async function () {\n    // randomly pick a device type\n    // nodeId ranges from 2 to 232. Hence array length +2\n    // logic to detemine model yet to be added.\n\n    // \t\tstate.devices = state._$gateway.devices\n\n    let deviceType = \"thermostat\";\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    model = chance.pickone(thermostat_models);\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.addLock = async function () {\n    // randomly pick a device type\n    // nodeId ranges from 2 to 232. Hence array length +2\n    // logic to detemine model yet to be added.\n\n    // \t\tstate.devices = state._$gateway.devices\n\n    let deviceType = \"lock\";\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    model = chance.pickone(lock_models);\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.addContactSensor = async function () {\n    let deviceType = \"contact_sensor\";\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    model = chance.pickone(contactsensor_models);\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.addMotionSensor = async function () {\n    let deviceType = \"motion_sensor\";\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    model = chance.pickone(motionsensor_models);\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.addSiren = async function () {\n    let deviceType = \"siren\";\n    let nodeId = state._$gateway.nextNodeId++;\n\n    let model = \"\";\n\n    model = chance.pickone(siren_models);\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            add_device: {\n              [nodeId]: [deviceType, model],\n            },\n          },\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    state.addDeviceTimerStart = Date.now();\n\n    return response;\n  };\n\n  hubFunctions.removeDevice = async function () {\n    let res = {};\n    if (\n      (Array.isArray(state._$gateway.devices) &&\n        state._$gateway.devices.length === 0) ||\n      state._$gateway.devices === undefined\n    ) {\n      console.log(\"ERR: No devices to delete\");\n      state.payload_err = \"No devices to delete\";\n    } else {\n      let device = chance.pickone(state._$gateway.devices);\n\n      let nodeId = \"\" + 1; //\"\" + device.nodeId;\n\n      state._$gateway.devices.forEach((device) => {\n        if (parseInt(device.nodeId) == nodeId) {\n          state.deletedDevice = device.deviceType;\n        }\n      });\n      //state.deletedDevice = device.deviceType;\n\n      res = {\n        state: {\n          reported: {\n            thing_name: state._$gateway.thingName,\n            notification: {\n              remove_device: {\n                [nodeId]: \"delete\",\n              },\n            },\n          },\n        },\n      };\n\n      state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    }\n\n    return res;\n  };\n\n  hubFunctions.sendConnectionType = async function () {\n    if (state._$gateway.connection.curr_conn_type === \"wifi\") {\n      state._$gateway.connection.wifi_ssid =\n        \"WIFI-\" +\n        chance.integer({\n          min: 1,\n          max: 50,\n        });\n      state._$gateway.connection.wifi_ss = chance.integer({\n        min: 0,\n        max: 100,\n      });\n    } else if (state._$gateway.connection.curr_conn_type === \"cellular\") {\n      state._$gateway.connection.csq =\n        \"\" +\n        chance.floating({\n          min: 1.99,\n          max: 32.99,\n          fixed: 2,\n        });\n    }\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: state._$gateway.connection,\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendBoardType = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: state._$gateway.board,\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendICCID = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          status: state._$gateway.sim,\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.factoryTest = async function () {\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          settings: state._$gateway.factory,\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.sendBLEmode = async function () {\n    let p = await state.hubFunctions.sendBLEcmd();\n    state._$helpers.publish(JSON.stringify(p));\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            mode: state._$gateway.ble.mode,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    return response;\n  };\n\n  hubFunctions.sendBLEcmd = async function () {\n    //if BLE mode is 'central', readyForBleCmds is true\n    //if BLE mode is 'peripheral', readyForBleCmds is false\n    state._$gateway.ble.readyForBleCmds = {\n      central: \"true\",\n      peripheral: \"false\",\n    }[state._$gateway.ble.mode];\n\n    let response = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            readyForBleCmds: state._$gateway.ble.readyForBleCmds,\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return response;\n  };\n\n  hubFunctions.rebootHub = async function () {\n    state.BootIterationsLeft = state._$REBOOT_SLEEP;\n    console.log(\"Starting Reboot\");\n\n    // state._$gateway.ble.mode = \"peripheral\";\n\n    await state.hubFunctions.switchPeripheral();\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n\n    console.log(\"SEQINFO: Going to Booting state\");\n    next(\"Booting\");\n    // return {};\n  };\n\n  hubFunctions.upgradeReport = async function () {\n    // Change to stateless - client token should be function param\n    // state.upgrade = {\n    //     clientToken: \"blah\"\n    // }\n    // TODO: model increments of version also\n    let res = {\n      cmd: \"report\",\n      data: {\n        version: \"2.09\",\n        networker: \"2.90\",\n        iotCount: 1,\n        tree: {\n          hub: \"8ebd67b673eb42a3e23865049cda3df9\",\n          modules: \"a5bc72da682103f1d58b8c3321f1a1e9\",\n        },\n        mountWanted: true,\n        mountActive: true,\n        hubWanted: true,\n        hubActive: false,\n        treeMode: \"idle\",\n        md5TreeBusy: false,\n      },\n      clientToken: state.upgrade.clientToken,\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/admin\";\n    return res;\n  };\n\n  hubFunctions.wifiScan = async function () {\n    // Change to stateless - client token should be function param\n    // state.scan = {\n    //     clientToken: \"blah\"\n    // }\n\n    let res = {\n      cmd: \"scan\",\n      clientToken: state.scan.clientToken,\n      data: {\n        wifi_ssids: [\"Test\", \"test1\"],\n      },\n    };\n\n    state.pubTopic = state._$gateway.thingName + \"/admin\";\n    return res;\n  };\n\n  hubFunctions.BLEscan = async function () {\n    console.log(shared.LockMACs[client()]);\n    state.MAC = shared.LockMACs[client()];\n    let res = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            scanDeviceReport: [\n              state.MAC,\n              chance.integer({\n                min: -100,\n                max: 0,\n              }),\n              chance.integer({\n                min: 0,\n                max: 1,\n              }),\n              chance.integer({\n                min: 0,\n                max: 1,\n              }),\n              chance.integer({\n                min: 0,\n                max: 100,\n              }),\n            ],\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n\n    // let z = await state.hubFunctions.BLEfirmware();\n    // state._$helpers.publish(z)\n\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return res;\n  };\n\n  hubFunctions.BLEfirmware = async function () {\n    // 1.10 .. 1.21\n    state.MAC = shared.LockMACs[client()];\n    let res = {\n      state: {\n        reported: {\n          thing_name: state._$gateway.thingName,\n          notification: {\n            lockFWVer: [\n              state.MAC,\n              chance.pickone([\"3.3\", \"3.4\", \"3.5\"]),\n            ],\n          },\n          updateTime: state._$timestamp.toISOString(),\n        },\n      },\n    };\n    state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n    return res;\n  };\n\n  hubFunctions.switchPeripheral = async function () {\n    state._$gateway.ble.mode = \"peripheral\";\n\n    let p = await state.hubFunctions.sendBLEmode();\n    state._$helpers.publish(JSON.stringify(p));\n    // state.PAYLOADS.push(p);\n    return {};\n  };\n  hubFunctions.switchCentral = async function () {\n    state._$gateway.ble.mode = \"central\";\n\n    let p = await state.hubFunctions.sendBLEmode();\n    state._$helpers.publish(JSON.stringify(p));\n    // state.PAYLOADS.push(p);\n    return {};\n  };\n\n  hubFunctions.triggerOffline = async function () {\n    state._$nextExecution.triggerClearingUnsent = Date.now() + 120000;\n\n    console.log(\"SEQINFO: Triggering next state to offline\");\n    next(\"Offline\");\n  };\n\n  hubFunctions.triggerClearingUnsent = async function () {\n    console.log(\"SEQINFO: Triggering next state to clearing_unsent\");\n\n    next(\"Clearing_Unsent\");\n  };\n\n  hubFunctions.getGateway = async function () {\n    let topic = \"$aws/things/\" + state._$gateway.thingName + \"/shadow/get\";\n    let payload = {};\n    console.log(\"Sending\", payload, \" to \", topic);\n    state.getGatewayTimerStart = Date.now();\n    state._$helpers.publish(payload, topic);\n  };\n\n  hubFunctions.logStatus = async function (mac) {\n    // console.log(\"enter into logstatus\");\n    //HERE\n    if (state.logSent == \"false\") {\n      if (\n        Object.keys(state.bleToken).length > 0 &&\n        state.bleToken?.token_exp >= Math.floor(Date.now() / 1000)\n      ) {\n        let message = \"Logs fetched and updated successfully\";\n        let success = 1;\n        let numberOfLogs = chance.integer({ min: 10, max: 80 });\n        let records = [];\n        for (i = 0; i < numberOfLogs; i++) {\n          await delay(1000);\n          let recordType = chance.integer({ min: 1, max: 40 });\n          let uid = chance.pickone([\"null\", 50, 100]);\n          let operateDate = new Date().toISOString().replace(\"T\", \" \").replace(\"Z\", \"\").split(\".\")[0]\n          let success = chance.integer({ min: 0, max: 1 });\n          //console.log(operateDate);\n          let record = { recordType, uid, operateDate, success };\n          records.push(record);\n        }\n        obj = {\n          lockMac: mac[0],\n          records: records,\n        };\n        console.log(records);\n        let urlPost =\n          \"https://cgtnmt5d06.execute-api.us-east-1.amazonaws.com/rentlypt/oakslock/logs/\";\n        let optionsPost = {\n          headers: {\n            \"content-type\": \"application/json\",\n            Authorization: \"Bearer \" + state?.bleToken?.token,\n          },\n        };\n        try {\n          //console.log(urlPost);\n          //console.log(optionsPost);\n          state.getRes = rest.post(urlPost, obj, optionsPost);\n          console.log(\"Success=>\", state.getRes)\n          console.log(\"Logs sent successfuly\");\n        } catch (e) {\n          message = \"No logs to be fetched\";\n          success = 0;\n          // console.error(e);\n          console.error(\"Error in getting logs\" + e);\n        }\n\n        let topic =\n          \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update\";\n        let payload = {\n          state: {\n            reported: {\n              thing_name: state._$gateway.thingName,\n              status: {\n                logReport: [mac[0], message, success,mac[1]],\n              },\n              updateTime: state._$timestamp.toISOString(),\n            },\n          },\n        };\n\n        console.log(\"Sending\", payload, \" to \", topic);\n        state.getGatewayTimerStart = Date.now();\n        state._$helpers.publish(payload, topic);\n        state.logSent = true;\n      } else {\n        if (state.tokenRequestSent == false) {\n          console.log(\"Fetching API Token for logs\");\n          await state._$helpers.checkBLEtoken();\n        } else {\n          state.hubFunctions.logStatus(mac);\n        }\n      }\n    }\n  };\n  //UPDATE\n  hubFunctions.updateFirmware = async function (params) {\n    console.log(\"enter into update firmware\");\n    let mac = params[0];\n    let version = params[1];\n    let url = params[2];\n    let checksum = params[3];\n    let retryid = params[6];\n    console.log(checksum);\n    try {\n      const response = await axios.get(url);\n      // console.log(response.data)\n      console.log(\"updatefirmware_1\");\n      var hashed = hash.md5(response.data);\n      console.log(\"hashdata =>\", hashed);\n      console.log(\"checksumdata=>\", checksum);\n\n      //if (hashed == checksum) {\n        console.log(\"Firmware updated successfully\");\n        let message = \"Firmware updated successfully\";\n        let success = 0;\n        let topic =\n          \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update\";\n        let payload = {\n          state: {\n            reported: {\n              thing_name: state._$gateway.thingName,\n              notification: {\n                updateFWverBLEReport: [mac, version, success, message,null, retryid],\n              },\n              updateTime: state._$timestamp.toISOString(),\n            },\n          },\n        };\n\n        //state._$gateway.firmware = version;\n\n        console.log(\"Sending good\", payload, \" to \", topic);\n        state.getGatewayTimerStart = Date.now();\n        state._$helpers.publish(payload, topic);\n     // } else {\n       // console.log(\"error in checksum\");\n     // }\n      // console.log(hashed)\n    } catch (error) {\n      console.log(\"Error in updatefirmware\");\n      console.error(error);\n    }\n  };\n  state.hubFunctions = hubFunctions;\n\n  state._$nextExecution = {};\n  state._$iterationConfig.forEach(function (obj) {\n    state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n  });\n\n  state._$helpers = {};\n\n  state._$helpers.initGateway = async function () {\n    state._$gateway.power = {\n      status: \"plugged\",\n      level: chance.integer({ min: 0, max: 100 }),\n    };\n    state._$gateway.devices = [];\n    state._$gateway.deviceGUIDs = [];\n    state._$gateway.locks = 0;\n    state._$gateway.thermostats = 0;\n    state._$gateway.nextNodeId = 2;\n    state._$gateway.firmware = { fwVer: chance.pickone(fwVer) };\n    state._$gateway.connection = {\n      curr_conn_type: chance.pickone(curr_conn_type),\n    };\n    state._$gateway.board = {\n      board_type: chance.pickone(board_type),\n      model: chance.pickone(model),\n    };\n    state._$gateway.sim = {\n      imei: chance.string({ length: 15, numeric: true }),\n      iccid: chance.string({ length: 19, numeric: true }),\n    };\n    state._$gateway.factory = {\n      rently_batch_code_duration: chance.integer({ min: 1, max: 4 }) * 30,\n      time_zone: chance.pickone(time_zone),\n      agingTest: chance.pickone([\"enable\", \"disable\"]),\n    };\n    state._$gateway.rebooting = { status: false };\n    state._$gateway.ble = { mode: \"central\" };\n\n    glob.set(\"gateway_\" + client(), state._$gateway);\n    console.log(\"SEQINFO: Completed Initializing Gateway.\");\n\n    return true;\n  };\n\n  state._$helpers.handleDelta = async function (res) {\n    let resub = false;\n    console.log(\"SEQINFO: Processing Delta\");\n    metric.add(\"Gateway_deltaProcessed\");\n    if (!!res.state) {\n      if (res.state.commands) {\n        let commands = res.state.commands;\n        metric.add(\"Gateway_deltaCommandRX\");\n\n        console.log(\"COMMANDS: \", commands);\n        let timestamps = Object.keys(commands);\n        console.log(\"enter into the loop to get updatefirmwareBLE\");\n        timestamps.forEach((timestamp) => {\n          if (commands[timestamp].command === \"getLogBLE\") {\n            let mac = commands[timestamp].params;\n\n            state.logSent = \"false\";\n            state.hubFunctions.logStatus(mac);\n          } else if (commands[timestamp].command === \"updateFirmwareBLE\") {\n            let params = commands[timestamp].params;\n            console.log(\"calling updateFirmware\");\n            state.hubFunctions.updateFirmware(params);\n          } else if (commands[timestamp].command === \"reboot\") {\n            console.log(\"calling reboot\");\n            // protocol.forceDisconnect();\n            // console.log(\"SEQINFO: Disconnected from MQTT topics\");\n            state.hubFunctions.rebootHub();\n          } else if (commands[timestamp].token) {\n            state.bleToken = {\n              token: commands[timestamp].token.accessToken,\n              token_exp: commands[timestamp].token.expiresAt,\n            };\n            state.tokenRequestSent = false;\n          }\n        });\n      } else if (res.state.settings.sensors) {\n        let sensors = res.state.settings.sensors;\n        let monitoring = res.state.settings.monitoring;\n\n        state.activeContactSensors =\n          (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n        state.activeMotionSensors =\n          (await glob.get(\"G\" + client() + \"_ActiveMotionSensors\")) || {};\n\n        let contactSensors = Object.keys(state.activeContactSensors);\n        let motionSensors = Object.keys(state.activeMotionSensors);\n\n        contactSensors.forEach(async (contactSensor) => {\n          let gateway = state._$gateway.thingName;\n          mailbox.post(\"\" + contactSensor + \"_cmd\", { gateway, sensors });\n          mailbox.post(\"\" + contactSensor + \"_cmd\", { gateway, monitoring });\n        });\n\n        motionSensors.forEach(async (motionSensor) => {\n          let gateway = state._$gateway.thingName;\n          mailbox.post(\"\" + motionSensor + \"_cmd\", { gateway, sensors });\n          mailbox.post(\"\" + motionSensor + \"_cmd\", { gateway, monitoring });\n        });\n      } else if (res.state.settings.rules) {\n        let rules = res.state.settings.rules;\n        console.log(\"Recieved rules for thermostat\")\n\n        state.activeThermostats = (await glob.get(\"G\" + client() + \"_ActiveThermostats\")) || {};\n\n        let thermostats = Object.keys(state.activeThermostats);\n\n        thermostats.forEach(async (thermostat) => {\n          let gateway = state._$gateway.thingName;\n          mailbox.post(\"\" + thermostat + \"_cmd\", { gateway, rules });\n          console.log(\"Rules sent to thermostat\")\n\n        });\n\n      } else if (res.state.settings.schedule) {\n        let scheduleId = res.state.settings.schedule;\n\n        let urlGet = \"https://keyless.rentlypt.com/api/schedules/\" + scheduleId;\n        let optionsGet = {\n          headers: {\n            \"content-type\": \"application/json\",\n            Authorization: \"Bearer \" + state?.token?.apiToken,\n          },\n        };\n        try {\n          state.getRes = rest.get(urlGet, optionsGet);\n        } catch (e) {\n          console.error(e);\n        }\n\n        if (state?.getRes?.settings?.monitoring) {\n          let monitoring = state.getRes.settings.monitoring;\n\n          state.activeContactSensors =\n            (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n          state.activeMotionSensors =\n            (await glob.get(\"G\" + client() + \"_ActiveMotionSensors\")) || {};\n\n          let contactSensors = Object.keys(state.activeContactSensors);\n          let motionSensors = Object.keys(state.activeMotionSensors);\n\n          contactSensors.forEach(async (contactSensor) => {\n            let gateway = state._$gateway.thingName;\n            mailbox.post(\"\" + contactSensor + \"_cmd\", { gateway, monitoring });\n          });\n\n          motionSensors.forEach(async (motionSensor) => {\n            let gateway = state._$gateway.thingName;\n            mailbox.post(\"\" + motionSensor + \"_cmd\", { gateway, monitoring });\n          });\n        } else {\n          console.error(\"No Schedule info returned \");\n        }\n      }\n\n      let deltaDevices = res?.state?.settings?.devices;\n\n      if (Array.isArray(deltaDevices)) {\n        console.log(\"Devices array is Present in the delta : \", deltaDevices);\n\n        state._$helpers.checkDevices(deltaDevices);\n\n        let count = 0;\n      } else {\n        console.log(\"No devices present in Delta\");\n        metric.add(\"Gateway_deltaReceivedWithoutDevices\");\n\n        // try {\n        //   state._$helpers.publish(\n        //     JSON.stringify(await state.hubFunctions.heartBeat())\n        //   );\n        // } catch (e) {\n        //   console.log(\"ERR: Error sending Heartbeat\", e);\n        // }\n      }\n      state.DELTA = res.state;\n      // if (state.MAX_VERBOSE) state.PREV_DELTAS.push(res);\n      let echo = {\n        state: {\n          reported: {\n            ...state.DELTA,\n            thing_name: state._$gateway.thingName,\n            updateTime: state._$timestamp.toISOString(),\n          },\n        },\n      };\n      // if (!!echo.state.reported?.settings?.devices) delete echo.state.reported.settings.devices\n      state._$helpers.publish(JSON.stringify(echo));\n      if (state.MAX_VERBOSE)\n        // console.log(\"Echo Accepted : \", JSON.stringify(res));\n        return true;\n    } else {\n      console.log(\"No state found in received delta\");\n      metric.add(\"Gateway_deltaReceivedWithoutState\");\n\n      return false;\n    }\n  };\n\n  state._$helpers.checkDevices = async function (desiredDevices) {\n    let resub = false;\n    console.log(\"Checking Devices\");\n    metric.add(\"Gateway_checkDevices\");\n\n    if (desiredDevices && Array.isArray(desiredDevices)) {\n      if (desiredDevices.length === 0) {\n        metric.add(\"Gateway_CheckingEmptyDeviceArray\");\n        console.log(\"Empty Devices Array\", desiredDevices);\n      }\n\n      console.log(\"INFO: Received devices : \", desiredDevices);\n      state.newDevices = _.difference(\n        desiredDevices,\n        state._$gateway.deviceGUIDs\n      );\n      state.removeDevices = _.difference(\n        state._$gateway.deviceGUIDs,\n        desiredDevices\n      );\n      console.log(\"New Devices Received: \", state.newDevices);\n      console.log(\"Missing Devices to be Removed: \", state.removeDevices);\n\n      if (state.newDevices.length > 0 || state.removeDevices.length > 0) {\n        let count = 0;\n        state.newDevices.forEach(async (device_thing_name) => {\n          if (!state._$gateway.deviceGUIDs.includes(device_thing_name)) {\n            console.log(\"Found New Device : \", device_thing_name);\n            if (!state.unverifiedDeviceGUIDs.includes(device_thing_name)) {\n              state.unverifiedDeviceGUIDs.push(device_thing_name);\n              resub = true;\n              state.subscriptionTopics.push(\n                \"$aws/things/\" + device_thing_name + \"/#\"\n              );\n              ++count;\n              metric.add(\n                \"Gateway_newDeltaDeviceTime\",\n                Date.now() - state.addDeviceTimerStart\n              );\n            } else {\n              console.log(\"Device already present in unverifiedDeviceGUIDs\");\n            }\n          } else {\n            console.log(\"Device already present in DeviceGUIDs\");\n          }\n        });\n        if (resub) {\n          protocol.resubscribe(state.subscriptionTopics);\n          metric.add(\"Gateway_resubscribe\");\n          console.log(\"Subscription Topics: \", state.subscriptionTopics);\n\n          glob.incr(\"Gateway_newDeltaDevice\", count);\n          metric.add(\"Gateway_newDeltaDevice\", count);\n        }\n\n        state.removeDevices.forEach(async (deviceGUID) => {\n          console.log(\"Removing device: \", deviceGUID, \" from gateway: \");\n          state._$gateway.devices = state._$gateway.devices.filter(\n            (device) => device.thing_name !== deviceGUID\n          );\n          state._$gateway.deviceGUIDs = state._$gateway.deviceGUIDs.filter(\n            (dev) => dev !== deviceGUID\n          );\n\n          let gatewayLocks =\n            (await glob.get(\"G\" + client() + \"_ActiveLocks\")) || {};\n          let gatewayThermostats =\n            (await glob.get(\"G\" + client() + \"_ActiveThermostats\")) || {};\n          let gatewayContactSensors =\n            (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n          let gatewayMotionSensors =\n            (await glob.get(\"G\" + client() + \"_ActiveMotionSensors\")) || {};\n          let gatewaySirens =\n            (await glob.get(\"G\" + client() + \"_ActiveSirens\")) || {};\n\n          if (!!gatewayLocks[deviceGUID]) {\n            console.log(\"deleting lock from ActiveLocks\");\n            delete gatewayLocks[deviceGUID];\n            await glob.set(\"G\" + client() + \"_ActiveLocks\", gatewayLocks);\n          }\n\n          if (!!gatewayThermostats[deviceGUID]) {\n            console.log(\"deleting Thermostat from ActiveThermostats\");\n            delete gatewayThermostats[deviceGUID];\n            await glob.set(\n              \"G\" + client() + \"_ActiveThermostats\",\n              gatewayThermostats\n            );\n          }\n          if (!!gatewayContactSensors[deviceGUID]) {\n            console.log(\"deleting ContactSesor from ActiveContactSensors\");\n            delete gatewayContactSensors[deviceGUID];\n            await glob.set(\n              \"G\" + client() + \"_ActiveContactSensors\",\n              gatewayContactSensors\n            );\n          }\n          if (!!gatewayMotionSensors[deviceGUID]) {\n            console.log(\"deleting MotionSensor from ActiveMotionSensors\");\n            delete gatewayMotionSensors[deviceGUID];\n            await glob.set(\n              \"G\" + client() + \"_ActiveMotionSensors\",\n              gatewayMotionSensors\n            );\n          }\n          if (!!gatewaySirens[deviceGUID]) {\n            console.log(\"deleting Siren from ActiveSirens\");\n            delete gatewaySirens[deviceGUID];\n            await glob.set(\"G\" + client() + \"_ActiveSirens\", gatewaySirens);\n          }\n        });\n        state.newDevices = [];\n        state.removeDevices = [];\n        console.log(\"Subscription Topics: \", state.subscriptionTopics);\n      }\n    } else {\n      console.log(\"ERR: devices passed is not an array \", desiredDevices);\n    }\n  };\n\n  state._$helpers.checkDevicesParity = async function () {\n    metric.add(\"Gateway_checkDevicesParity\");\n    console.log(\"SEQINFO: Checking parity of devices Array\");\n    if (state._$gateway.nextNodeId > 2) {\n      let activeDeviceCount = state._$gateway.deviceGUIDs.length || 0;\n      console.log(\n        \"INFO: Active Device Count for this Gateway : \",\n        activeDeviceCount\n      );\n      if (state._$gateway.nextNodeId - 2 !== activeDeviceCount) {\n        console.log(\"INFO: Triggering get request for Gateway\");\n        await state.hubFunctions.getGateway();\n        metric.add(\"Gateway_getGateway\");\n      } else {\n        console.log(\"Active device count is same as requests sent.\");\n      }\n    } else {\n      console.log(\"INFO: No device requests were sent by this gateway\");\n    }\n  };\n\n  state._$helpers.newDevice = async function (res) {\n    if (\n      res?.state?.desired?.thing_name &&\n      !state._$gateway.deviceGUIDs.includes(res?.state?.desired?.thing_name)\n    ) {\n      metric.add(\"Gateway_NewDeviceResponse\");\n      state.NEWDEVICERES = res;\n      let newDevice = {\n        thing_name: res?.state?.desired?.thing_name,\n        nodeId: res?.state?.desired?.settings?.node_no,\n        deviceType: res?.state?.desired?.settings?.type,\n      };\n\n      console.log(\"New device created is : \", newDevice);\n\n      if (newDevice.deviceType === \"lock\") {\n        state._$gateway.locks++;\n        // newDevice.globKey = \"L\" + state._$gateway.locks + \"G\" + client();\n        // await glob.set(newDevice.globKey, newDevice);\n        // await mailbox.post('G' + index() + '_Locks', newDevice)\n        let gatewayLocks =\n          (await glob.get(\"G\" + client() + \"_ActiveLocks\")) || {};\n        gatewayLocks[newDevice.thing_name] = newDevice;\n        await glob.set(\"G\" + client() + \"_ActiveLocks\", gatewayLocks);\n        console.log(\"Stored Lock to G\" + client() + \"_ActiveLocks\");\n        metric.add(\"Gateway_lockCreationComplete\");\n      } else if (newDevice.deviceType === \"thermostat\") {\n        state._$gateway.thermostats++;\n        let gatewayThermostats =\n          (await glob.get(\"G\" + client() + \"_ActiveThermostats\")) || {};\n        gatewayThermostats[newDevice.thing_name] = newDevice;\n        await glob.set(\n          \"G\" + client() + \"_ActiveThermostats\",\n          gatewayThermostats\n        );\n        console.log(\"Stored Thermostat to G\" + client() + \"_ActiveThermostats\");\n        metric.add(\"Gateway_thermostatCreationComplete\");\n      } else if (newDevice.deviceType === \"contact_sensor\") {\n        state._$gateway.contactsensors++;\n        let gatewayContactSensors =\n          (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n        gatewayContactSensors[newDevice.thing_name] = newDevice;\n        await glob.set(\n          \"G\" + client() + \"_ActiveContactSensors\",\n          gatewayContactSensors\n        );\n        console.log(\n          \"Stored ContactSensor to G\" + client() + \"_ActiveContactSensors\"\n        );\n        metric.add(\"Gateway_contactsensorCreationComplete\");\n      } else if (newDevice.deviceType === \"motion_sensor\") {\n        state._$gateway.motionsensors++;\n        let gatewayMotionSensors =\n          (await glob.get(\"G\" + client() + \"_ActiveMotionSensors\")) || {};\n        gatewayMotionSensors[newDevice.thing_name] = newDevice;\n        await glob.set(\n          \"G\" + client() + \"_ActiveMotionSensors\",\n          gatewayMotionSensors\n        );\n        console.log(\n          \"Stored MotionSensor to G\" + client() + \"_ActiveMotionSensors\"\n        );\n        metric.add(\"Gateway_motionsensorCreationComplete\");\n      } else if (newDevice.deviceType === \"siren\") {\n        state._$gateway.sirens++;\n        let gatewaySirens =\n          (await glob.get(\"G\" + client() + \"_ActiveSirens\")) || {};\n        gatewaySirens[newDevice.thing_name] = newDevice;\n        await glob.set(\"G\" + client() + \"_ActiveSirens\", gatewaySirens);\n        console.log(\"Stored Siren to G\" + client() + \"_ActiveSirens\");\n        metric.add(\"Gateway_sirenCreationComplete\");\n      }\n\n      console.log(\n        \"Removing \" + newDevice.thing_name + \" from unverified devices\"\n      );\n      state.unverifiedDeviceGUIDs = state.unverifiedDeviceGUIDs.filter(\n        (deviceGUID) => deviceGUID !== newDevice.thing_name\n      );\n\n      console.log(\"New Device : \", newDevice);\n      console.log(\"Pending unverified devices : \", state.unverifiedDeviceGUIDs);\n\n      state._$gateway.devices.push(newDevice);\n      state._$gateway.deviceGUIDs.push(res?.state?.desired?.thing_name);\n    } else {\n      console.log(\"INFO: Duplicate handler\");\n    }\n\n    glob.set(\"gateway_\" + client(), state._$gateway);\n    return true;\n  };\n\n  state._$helpers.checkManualTrigger = async function () {\n    let manualTrigger = await glob.get(\"manualTrigger\");\n\n    if (manualTrigger.count > state.gatewayManualTriggerCount) {\n      console.log(\"INFO: Received Manual Trigger for \" + manualTrigger.fun);\n\n      let check = state._$iterationConfig.find(\n        (o) => o.fun === manualTrigger.fun\n      );\n\n      if (!check) {\n        console.log(\n          \"ERR: Invalid Manual Trigger. Function doesn't exist in iterationConfig.\"\n        );\n        return false;\n      } else {\n        state.pendingManualTriggerFunction = manualTrigger.fun;\n        state.startIteration = index() + 1;\n\n        state.clientBatch = Math.ceil(jobClients() / manualTrigger.spread);\n        ++state.gatewayManualTriggerCount;\n        console.log(\"INFO: Set Pending Manual Trigger to \" + manualTrigger.fun);\n        // glob.incr(\"manualTriggerCount\",1);\n        metric.add(\"Gateway_pendingManualTrigger\");\n      }\n    } else {\n      // state.manualTriggerFunction = \"\";\n    }\n    if (\n      !!state.pendingManualTriggerFunction &&\n      Math.floor(client() / state.clientBatch) == index() - state.startIteration\n    ) {\n      state.manualTriggerFunction = state.pendingManualTriggerFunction;\n      state.pendingManualTriggerFunction = false;\n      console.log(\n        \"INFO: Set State Manual Trigger to \" + state.manualTriggerFunction\n      );\n      glob.incr(\"manualTriggerCount\", 1);\n      metric.add(\"Gateway_manualTrigger\");\n    } else {\n      state.manualTriggerFunction = \"\";\n    }\n  };\n\n  state._$helpers.handleHubCommand = async function (res) {\n    if (res && res.cmd === \"upgrade\") {\n      console.log(\"Received UPGRADE command\");\n      state.pubTopic = state._$gateway.thingName + \"/admin\";\n      state.upgrade = {\n        clientToken: res.clientToken,\n      };\n      let obj = {\n        fun: \"upgradeReport\",\n      };\n      // state._$queue.push(obj);\n      let p = await state.hubFunctions.upgradeReport();\n      state._$helpers.publish(\n        JSON.stringify(p),\n        \"$aws/things/\" + state.pubTopic\n      );\n      // state.PAYLOADS.push(p);\n    } else if (res && res.cmd === \"scan\") {\n      //TODO: refactor to account for topic change in queue\n      console.log(\"Received SCAN command\");\n      state.pubTopic = state._$gateway.thingName + \"/admin\";\n      state.scan = {\n        clientToken: res.clientToken,\n      };\n      let obj = {\n        fun: \"wifiScan\",\n      };\n      // state._$queue.push(obj);\n      let p = await state.hubFunctions.wifiScan();\n      state._$helpers.publish(\n        JSON.stringify(p),\n        \"$aws/things/\" + state.pubTopic\n      );\n      // state.PAYLOADS.push(p);\n    } else if (res && res.cmd === \"Reboot\") {\n      /*\n291<=========>\ntopic : $aws/things/113385/hub\nmessage : {\"cmd\":\"Reboot\",\"clientToken\":\"113385-1642506644\"}\n<=========>\n */\n      console.log(\"SEQINFO: Received Reboot command\");\n      // Ack message to be added here.\n\n      await state.hubFunctions.rebootHub();\n    } else if (res && res.cmd === \"tree\") {\n      console.log(\"Received TREE command\");\n\n      let bin = rest.get(\n        \"https://rentlypt-hub-trees.s3.amazonaws.com/test-da964c401418df9328d374e9dfc6ecc2.tgz\"\n      );\n      if (!bin) {\n        state.payload_err = {\n          error: true,\n          iteration: state.iteration - 1,\n          msg: \"Failed to get firmware\",\n        };\n      } else {\n        state.tree = {\n          clientToken: res.clientToken,\n          ver: res.tree,\n        };\n        // state._$gateway = glob.get(\"gateway_\" + client());\n        state._$gateway.firmware = {\n          fwVer: res.tree,\n        };\n\n        // TODO:\n        // GET req to S3 bucket\n        // check if checksum matches\n        glob.set(\"gateway_\" + client(), state._$gateway);\n\n        // let obj = {\n        //   fun: \"sendFWver\",\n        // };\n        // state._$queue.push(obj); TODO\n        let p = await state.hubFunctions.sendFWver();\n        state._$helpers.publish(JSON.stringify(p));\n        // state.PAYLOADS.push(p);\n      }\n    }\n  };\n\n  state._$helpers.verifyDevices = async function () {\n    metric.add(\"Gateway_verifyDevices\");\n    console.log(\"SEQINFO: Verifying Devices\");\n    state.unverifiedDeviceGUIDs.forEach(async (deviceGUID) => {\n      if (state._$gateway.deviceGUIDs.includes(deviceGUID)) {\n        console.log(\n          \"\" +\n            deviceGUID +\n            \"Already exists in gateway. Removing from unverified list\"\n        );\n        state.unverifiedDeviceGUIDs = state.unverifiedDeviceGUIDs.filter(\n          (unverifiedDeviceGUID) => unverifiedDeviceGUID !== deviceGUID\n        );\n      } else {\n        console.log(\n          \"Sending {}} to topic : \" +\n            \"$aws/things/\" +\n            deviceGUID +\n            \"/shadow/get\"\n        );\n\n        state._$helpers.publish(\n          JSON.stringify({}),\n          \"$aws/things/\" + deviceGUID + \"/shadow/get\"\n        );\n        state.PAYLOADS.push(\n          \"Verification req sent to \" +\n            \"$aws/things/\" +\n            deviceGUID +\n            \"/shadow/get\"\n        );\n        metric.add(\"Gateway_getDevice\");\n        state.deviceVerificationTimerStart = Date.now();\n      }\n    });\n  };\n\n  state._$helpers.publish = async function (payload, topic) {\n    metric.add(\"Gateway_MQTTpublish\");\n    // topic = topic || null\n    console.log(\"Publishing to MQTT\");\n    protocol.publish(payload, topic);\n  };\n\n  state._$helpers.checkBLEtoken = async function () {\n    console.log(\"Inside checkBLEToken\");\n    if (state.tokenRequestSent == false) {\n      if (\n        Object.keys(state.bleToken).length == 0 ||\n        state.bleToken?.token_exp <= Math.floor(Date.now() / 1000)\n      ) {\n        console.log(\"SEQINFO: Fetching new BLE token\");\n        let topic =\n          \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update\";\n\n        let payload = {\n          state: {\n            reported: {\n              thing_name: state._$gateway.thingName,\n              notification: {\n                fetchToken: state.MAC,\n              },\n              updateTime: state._$timestamp.toISOString(),\n            },\n          },\n        };\n\n        state._$helpers.publish(payload, topic);\n        state.tokenRequestSent = true;\n      } else {\n        console.log(\n          \"INFO: Glob contains valid Rently BLE Token : \",\n          state.bleToken\n        );\n      }\n    }\n  };\n\n  state._$helpers.checkAPItoken = async function () {\n    state.token = await glob.get(\"APItoken\");\n    if (\n      !state.token ||\n      state.token?.token_exp <= Math.floor(Date.now() / 1000)\n    ) {\n      console.log(\"SEQINFO: Fetching new token\");\n      let obj = {\n        grant_type: \"password\",\n        username:\n          state.config?.API_TOKEN_CREDENTIALS?.username ||\n          \"latitudeadmin@rently.com\",\n        password: state.config?.API_TOKEN_CREDENTIALS?.password || \"iotify@123\",\n      };\n\n      let options = {\n        // url: \"https://keyless.rentlypt.com/api/agents\",\n        // url: \"https://3ifxo.sse.codesandbox.io/rate\",\n        // json: obj,\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n      };\n\n      try {\n        let r = await rest.post(\n          \"https://keyless.rentlypt.com/api/agents\",\n          obj,\n          options\n        );\n        console.log(\"RES\", r);\n        state.token = {\n          apiToken: r.access_token,\n          token_exp: Math.floor(Date.now() / 1000) + r.expires_in,\n        };\n        console.log(\"SEQINFO: Updated token: \", state.token);\n        await glob.set(\"APItoken\", state.token);\n      } catch (e) {\n        console.log(\"ERR: Failed to get API token\");\n      }\n    } else {\n      console.log(\"INFO: Glob contains valid Rently API Token : \", state.token);\n    }\n  };\n\n  if (!state._$gateway?.initialized)\n    state._$gateway.initialized = await state._$helpers.initGateway();\n\n  if (state._$gateway?.deviceGUIDs && state._$gateway.deviceGUIDs.length > 0) {\n    console.log(\"INFO: Resubscribing to device topics\");\n    state._$gateway.deviceGUIDs.forEach((device_thing_name) => {\n      state.subscriptionTopics.push(\n        \"$aws/things/\" + device_thing_name + \"/shadow/update/delta\"\n      );\n    });\n    // await protocol.resubscribe(state.subscriptionTopics);\n\n    let resubStatus = await protocol.resubscribe(state.subscriptionTopics);\n\n    // console.log(\"Resub\", resubStatus  );\n\n    if (!!resubStatus) {\n      console.log(\"Resubscription successful\");\n      metric.add(\"Gateway_resubscribeSuccess\");\n    } else {\n      console.log(\"Resubscription Failed\");\n      metric.add(\"Gateway_resubscribeFail\");\n    }\n    console.log(\"Subscription Topics: \", state.subscriptionTopics);\n  }\n\n  console.log(\"SEQINFO: Completed Helper State.\");\n  state.BootIterationsLeft = 1;\n\n  // Temporary\n  // state._$gateway.nextNodeId = 7;\n\n  // state._$timestamp = new Date();\n  // state._$helpers.publish(JSON.stringify(await state.hubFunctions.heartBeat()))\n  {\n    let sensors = \"enable\";\n    let monitoring = \"arm_out\";\n\n    state.activeContactSensors =\n      (await glob.get(\"G\" + client() + \"_ActiveContactSensors\")) || {};\n    state.activeMotionSensors =\n      (await glob.get(\"G\" + client() + \"_ActiveMotionSensors\")) || {};\n\n    let contactSensors = Object.keys(state.activeContactSensors);\n    let motionSensors = Object.keys(state.activeMotionSensors);\n\n    contactSensors.forEach(async (contactSensor) => {\n      let gateway = state._$gateway.thingName;\n      mailbox.post(\"\" + contactSensor + \"_cmd\", { gateway, sensors });\n      mailbox.post(\"\" + contactSensor + \"_cmd\", { gateway, monitoring });\n    });\n\n    motionSensors.forEach(async (motionSensor) => {\n      let gateway = state._$gateway.thingName;\n      mailbox.post(\"\" + motionSensor + \"_cmd\", { gateway, sensors });\n      mailbox.post(\"\" + motionSensor + \"_cmd\", { gateway, monitoring });\n    });\n  }\n\n  metric.add(\"Gateway_helperStateComplete\");\n  next(\"Booting\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        },
        "Init": {
          "name": "Init",
          "isEnabled": true,
          "sender": "// This version clears the device deltas in the gateway template itself\n/*\n CHANGELOG\n\n 08-02-2022 \n\n - changed delay in publishing mailbox messages from 300 to 1000\n - wrapped protocol.publish in state._$helpers.publish for metrics\n - Changed wildcard ('/#') mqtt subscription to specific topics  \n\n */\n{\n  // Fetch necessary Glob Objects\n\n  state._$key = glob.get(\"gateway_\" + client() + \"_key\");\n  state._$cert = glob.get(\"gateway_\" + client() + \"_cert\");\n  state._$gateway = glob.get(\"gateway_\" + client());\n\n  console.log(\"Initial Gateway State : \", state._$gateway);\n\n  // Read configs\n  let config = glob.get(\"config\");\n\n  state._$iterationConfig = config?.iterationConfig?.gateway || []; // Contains interval for all functions\n  state._$REBOOT_SLEEP = config?.REBOOT_SLEEP || 5; // Number of iterations for sleeping during reboot\n  state.MAX_VERBOSE = config?.MAX_VERBOSE || true; // Toggle maximum verbosity of logs\n  state.CHECK_PARITY = config?.CHECK_PARITY || false; // Sets parity check for gateway devices\n  // state.SPREAD_MANUAL_TRIGGER = config?.SPREAD_MANUAL_TRIGGER || 10 // sets the number of iterations the manual trigger should be spread over.\n\n  console.log(\"INFO: REBOOT_SLEEP is set to : \", state._$REBOOT_SLEEP);\n  console.log(\"INFO: MAX_VERBOSE is set to : \", state.MAX_VERBOSE);\n  if (state.MAX_VERBOSE)\n    //console.log(\"Iteration Config : \", state._$iterationConfig);\n\n  // Init state variables with default values\n  state._$unsentBuffer = [];\n  state.newDevices = [];\n  state.removeDevices = [];\n  state.unverifiedDeviceGUIDs = [];\n  state.PAYLOADS = [];\n  state.PREV_DELTAS = [];\n  state.pubTopic = state._$gateway.thingName + \"/shadow/update\";\n  state.gatewayManualTriggerCount = 0;\n  state.subscriptionTopics = [];\n  state._$unprocessedDeltas = [];\n  state._$unprocessedDeviceShadow = [];\n  state.pendingManualTriggerFunction = false;\n  state.bleToken={}\n  state.disconnected = false;\n  state.tokenRequestSent = false;\n  state.gatewaySubTopics = [\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/delta\",\n    \"$aws/things/\" + state._$gateway.thingName + \"/hub\",\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/rejected\",\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/get/accepted\"\n  ]\n\n  state.subscriptionTopics.push(\n    \"$aws/things/\" + state._$gateway.thingName + \"/#\"\n    // ...state.gatewaySubTopics\n  );\n\n  if (client() === 0) {\n    let manualTrigger = {\n      fun: \"\",\n      count: 0,\n      spread: 1,\n    };\n    await glob.set(\"manualTrigger\", manualTrigger);\n    await glob.set(\"manualTriggerCount\", 0);\n    await glob.set(\"Gateway_newDeltaDevice\", 0);\n    state.config = {\n      API_TOKEN_CREDENTIALS: config?.API_TOKEN_CREDENTIALS,\n    };\n  }\n\n  //await mailbox.delete(\"Gateway_\" + client() + \"_tx\");\n\n  next(\"Helpers\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 0
        },
        "Online": {
          "name": "Online",
          "isEnabled": true,
          "sender": "{\n  await metric.add(\"Gateway_iterationStart_\"+index());\n  try {\n    state._$timestamp = new Date();\n\n    await state._$helpers.checkManualTrigger();\n\n    if (client() === 0) {\n      await state._$helpers.checkAPItoken();\n    }\n\n    await state._$helpers.checkBLEtoken();\n\n    state._$iterationConfig.forEach(async function (obj) {\n      if (\n        Date.now() >= state._$nextExecution[obj.fun] ||\n        obj.fun === state?.manualTriggerFunction\n      ) {\n        console.log(\"TRIGGER: \", obj.fun);\n        try {\n          let tsStart = Date.now();\n          let payload = await state.hubFunctions[obj.fun]();\n          await state._$helpers.publish(JSON.stringify(payload));\n          let tsEnd = Date.now();\n          metric.add(\"Gateway_\" + obj.fun + \"_duration\", tsEnd - tsStart);\n          //state.PAYLOADS.push(payload);\n          state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n        } catch (e) {\n          console.log(\"ERR: \", e);\n        }\n\n        await metric.add(\"Gateway_\" + obj.fun);\n        await delay(100);\n      }\n    });\n\n  \n    if (state.unverifiedDeviceGUIDs.length > 0) {\n      await state._$helpers.verifyDevices();\n    }\n\n  \n    let mailboxReadStart = Date.now();\n    //let fifo = [];\n\n    for (let i = 0; i < 25; ++i) {\n      let count = await mailbox.count(\"Gateway_\" + client() + \"_tx\");\n      if (count > 0) {\n\n        try {\n          let mailbox_message = await mailbox.pop(\"Gateway_\" + client() + \"_tx\");\n          console.log(mailbox_message)\n          if (\n            typeof mailbox_message.topic === \"string\" && !!mailbox_message?.payload?.state  ) {\n            console.log(\"INFO: Publishing message to : \" + mailbox_message.topic);\n            //fifo.push({ payload: mailbox_message.payload, topic: mailbox_message.topic });\n\n            state._$helpers.publish(mailbox_message.payload, mailbox_message.topic);\n            delay(1000)\n            metric.add(\"Gateway_deviceMessageSent\");\n          } else {\n            console.log(\"ERR: Invalid Mailbox message received\");\n          }\n        } catch (e) {\n          console.log(\"ERR: Error clearing mailbox.\", e)\n        }\n      }\n    }\n\n    let mailboxReadEnd = Date.now();\n    metric.add(\n      \"Gateway_mailboxReadDuration\",\n      mailboxReadEnd - mailboxReadStart\n    );\n\n    if (state._$unprocessedDeltas.length > 0) {\n      console.log(\"Unprocessed Deltas present. Length: \" + state._$unprocessedDeltas.length);\n\n      let deltaProcessStart = Date.now()\n\n      for (let i = 0; i < Math.min(100, state._$unprocessedDeltas.length); ++i){\n        let delta = state._$unprocessedDeltas.shift()\n        try {\n          await state._$helpers.handleDelta(delta);\n        } catch (e) {\n          console.log(\"ERR: Handle Delta Failed \", e);\n        }\n      }\n      \n\n      metric.add('Gateway_deltaProcessTime', (Date.now() - deltaProcessStart))\n    }\n\n    if (state._$unprocessedDeviceShadow.length > 0) {\n      console.log(\"Unprocessed Shadows present. Length: \" + state._$unprocessedDeviceShadow.length);\n\n      let shadowProcessStart = Date.now()\n\n      for (let i = 0; i < Math.min(100, state._$unprocessedDeviceShadow.length ); ++i) {\n        let shadow = state._$unprocessedDeviceShadow.shift()\n        try {\n          await state._$helpers.newDevice(shadow);\n        } catch (e) {\n          console.log(\"ERR: Handle Shadow Failed \", e);\n        }\n      }\n\n      metric.add('Gateway_deviceShadowProcessTime', (Date.now() - shadowProcessStart))\n    }\n\n    if (state.CHECK_PARITY && (index() % 10 === 0 || index() === 2))\n      state._$helpers.checkDevicesParity();\n\n    glob.set(\"gateway_\" + client(), state._$gateway);\n\n    state.PAYLOADS = state.PAYLOADS.slice(0, 9);\n    state.PREV_DELTAS = state.PREV_DELTAS.slice(0, 9);\n\n    // next(\"Online\");\n    state.ITERATION = \"ITERATION: \" + index();\n   \n  } catch (e) {\n    console.log(\"ERR: Error in Online State: \", e);\n  }\n  if (iteration() === jobRepeat() - 2) next(\"Finished\");\n}\n",
          "receiver": "{\n  metric.add('Gateway_onlineStateRH')\n  let tsStart = Date.now();\n  console.log(\"RH : Iteration: \" + index() + \" | Topic: \", response.topic);\n  let topic = response.topic;\n  if (!topic || topic.split(\"/\").length < 3) return\n  if (!response?.message) return\n  \n  let res = {};\n\n  try {\n\n    res = await JSON.parse(response?.message.toString());\n  } catch (e) {\n    console.log(\"ERR: Failed to parse response \", e, response.message);\n  }\n  // state._$gateway = await glob.get(\"gateway_\" + client());\n\n  let device_thing_name = topic.split(\"/\")[2] || \"\";\n  console.log(\"Received Message for :\", device_thing_name);\n\n  if (\n    topic ===\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/delta\"\n  ) {\n    metric.add('Gateway_deltaRH')\n    // try {\n    //   await state._$helpers.handleDelta(res);\n    // } catch (e) {\n    //   console.log(\"ERR: Handle Delta Failed \", e);\n    // }\n    if (!!res.state) {\n      state._$unprocessedDeltas.push(res)\n      console.log(\"Received Delta pushed to processing queue. Queue Length : \" + state._$unprocessedDeltas.length)\n    } else {\n      console.log(\"Ignoring Delta: contains no state\")\n      metric.add('Gateway_deltaReceivedWithoutState')\n\n    }\n    \n  }\n  // else if (\n  //   topic ===\n  //   \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/documents\"\n  // ) {\n  //   metric.add('shadow_document')\n  //   if (Array.isArray(res.current?.state?.desired?.settings?.devices) && res.current?.state?.desired?.settings?.devices.length > 0) metric.add('shadow_document_devices')\n  //   console.log(\"Received /update/document contains devices : \", res.current?.state?.desired?.settings?.devices)\n  //   try {\n  //     await state._$helpers.checkDevices(\n  //       res.current?.state?.desired?.settings?.devices\n  //     );\n  //   } catch (e) {\n  //     console.log(\"ERR: Handle Document Failed \", e);\n  //   }\n  // }\n  else if (topic === \"$aws/things/\" + state._$gateway.thingName + \"/hub\") {\n    console.log(\"Received hub command\");\n    metric.add('Gateway_hubCommandRX');\n    state._$helpers.handleHubCommand(res);\n  } else if (\n    topic ===\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/update/rejected\"\n  ) {\n    console.log(\"Received Reject message\", JSON.stringify(res));\n    metric.add(\"Gateway_payloadRejected\");\n  } else if (\n    topic ===\n    \"$aws/things/\" + state._$gateway.thingName + \"/shadow/get/accepted\"\n  ) {\n    console.log(\"Received Gateway Get Response\");\n    metric.add(\"Gateway_GetResponse\");\n    metric.add('Gateway_GetResponseTime', (Date.now() - state?.getGatewayTimerStart))\n    if (\n      Array.isArray(res?.state?.desired?.settings?.devices) &&\n      res?.state?.desired?.settings?.devices.length > 0\n    ) {\n      await state._$helpers.checkDevices(\n        res?.state?.desired?.settings?.devices\n      );\n    } else {\n      console.log(\"INFO: Get Response contains no devices array\");\n      if (state.MAX_VERBOSE) console.log(JSON.stringify(res));\n    }\n  }  else if (\n    state.unverifiedDeviceGUIDs.includes(device_thing_name) &&\n    topic === \"$aws/things/\" + device_thing_name + \"/shadow/get/accepted\"\n  ) {\n    metric.add(\"Gateway_getDeviceResponse\");\n    metric.add(\"Gateway_getDeviceResponseTime\", (Date.now() - state?.deviceVerificationTimerStart));\n    state._$unprocessedDeviceShadow.push(res)\n    console.log(\"SEQINFO: Pusing shadow to unprocessed queue. Queue Length: \" + state._$unprocessedDeviceShadow.length);\n\n\n  } else if (state._$gateway.deviceGUIDs.includes(device_thing_name)) {\n    console.log(\"SEQINFO: Pushing to mailbox \", \"\" + device_thing_name + \"_rx\");\n    metric.add(\"Gateway_deviceMessagesReceived\");\n    mailbox.post(\"\" + device_thing_name + \"_rx\", { topic, res });\n    let count = await mailbox.count(\"\" + device_thing_name + \"_rx\");\n    console.log(\"Mailbox count of \" + device_thing_name + \"_rx : \" + count);\n\n    if (topic === \"$aws/things/\" + device_thing_name + \"/shadow/update/delta\" && !!res?.state) {\n      console.log('Echoing back delta for device ' + device_thing_name);\n      let x = {\n        state: {\n          reported: {\n            ...res.state,\n            thing_name: device_thing_name,\n            updateTime: state._$timestamp.toISOString(),\n          },\n        },\n      };\n      await state._$helpers.publish(x, \"$aws/things/\" + device_thing_name + \"/shadow/update\")\n      await metric.add(\"Gateway_deviceDeltaEchoSent\")\n      console.log(\"Echo back sent\")\n    }\n  }\n  let tsEnd = Date.now();\n  metric.add(\"RH_duration\", tsEnd - tsStart);\n}\n",
          "icon": "",
          "index": 4
        },
        "Finished": {
          "name": "Finished",
          "isEnabled": true,
          "sender": "\n{\n  let devices = state._$gateway.deviceGUIDs\n\n  glob.incr('shadowDevice', devices.length)\n  metric.add('Stripped_totalDevices', devices.length)\n  console.log(\"state._$gateway.deviceGUIDs.length=\" + devices.length)\n  console.log(state._$gateway.deviceGUIDs)\n  \n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n",
          "icon": "",
          "index": 6
        },
        "Offline": {
          "index": 5,
          "name": "Offline",
          "isEnabled": false,
          "sender": "\n{\n  console.log(\"OFFLINESTART\", state.disconnected);\n  if (state.disconnected == false) {\n    protocol.forceDisconnect();\n    console.log(\"SEQINFO: Disconnected from MQTT topics\");\n    state.disconnected = true;\n  }\n\n  metric.add('Gateway_offlineState')\n  state._$timestamp = new Date();\n  state._$iterationConfig.forEach(async function (obj) {\n    if (Date.now() >= state._$nextExecution[obj.fun]) {\n      state._$nextExecution[obj.fun] = Date.now() + obj.interval;\n\n      console.log(\"TRIGGER: \", obj.fun);\n      payload = await state.hubFunctions[obj.fun]();\n      state._$unsentBuffer.push(payload);\n    }\n  });\n  console.log('SEQINFO: In Offline State')\n  console.log('DBGINFO: Unsent Buffer Length : ' + state._$unsentBuffer.length);\n\n  if(state.MAX_VERBOSE) console.log('VERBOSE: ', JSON.stringify(state._$unsentBuffer))\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        },
        "Booting": {
          "index": 2,
          "name": "Booting",
          "isEnabled": true,
          "sender": "{\n  if (iteration() > 2 && state.disconnected == false) {\n    protocol.forceDisconnect();\n    console.log(\"SEQINFO: Disconnected from MQTT topics\");\n    state.disconnected = true;\n  }\n\n  state._$timestamp = new Date();\n  await glob.set(\"gateway_\" + client() + \"_active\", false);\n\n  //if (--state.BootIterationsLeft <= 0) {   // TBD check with Robin about the logic here\n  if (--state.BootIterationsLeft <= 0) {\n    console.log(\"SEQINFO: Done Booting\");\n    if (iteration() > 2) {\n      console.log(\"SEQINFO: Reconnecting to MQTT topics\");\n      protocol.forceConnect();\n      state.disconnected = false;\n    }\n\n    try {\n      metric.add('Gateway_heartBeat')\n      await state._$helpers.publish(JSON.stringify(await state.hubFunctions.heartBeat()));\n      await delay(2000);\n      // await state._$helpers.publish(JSON.stringify(await state.hubFunctions.switchPeripheral ()));\n      \n      //  await delay(2000)\n      await state._$helpers.publish(JSON.stringify(await state.hubFunctions.sendFWver()));\n      await delay(2000)\n      \n      await state._$helpers.publish(JSON.stringify(await state.hubFunctions.BLEscan()));\n      await delay(2000)\n\n      // await state._$helpers.publish(JSON.stringify(await state.hubFunctions.sendICCID()));\n      // await delay(2000)\n\n      // await state._$helpers.publish(JSON.stringify(await state.hubFunctions.sendBoardType()));\n      // await delay(2000)\n\n      \n\n      await state._$helpers.publish(JSON.stringify(await state.hubFunctions.sendBLEmode()));\n      await delay(2000)\n    } catch (e) {\n      console.log(e);\n    }\n    \n    state._$nextExecution.switchCentral = Date.now() + 180000;\n    glob.set(\"gateway_\" + client() + \"_active\", true);\n    metric.add('Gateway_bootingStateComplete', 1)\n    next(\"Online\");\n  }\n  metric.add('Gateway_bootingState', 1)\n  console.log(\"SEQINFO: In Booting State\");\n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        },
        "Clearing_Unsent": {
          "index": 3,
          "name": "Clearing_Unsent",
          "isEnabled": false,
          "sender": "{\n  if (iteration() > 2 && state.disconnected == true) {\n    console.log(\"SEQINFO: Reconnecting to MQTT topics\");\n    protocol.forceConnect();\n    state.disconnected = false;\n  }\n\n  while (state._$unsentBuffer.length > 0) {\n    await delay(100)\n    await state._$helpers.publish(JSON.stringify(state._$unsentBuffer.shift()));\n  }\n\n  console.log('SEQINFO: Completed Clearing Unsent State.')\n  next('Online');\n  \n}\n",
          "receiver": "\n{\n  //Please provide your logic here. \n  \n  //The device model state could be transitioned by calling next()\n  //To transition to a specific state pass state name as argument e.g. \n  //next('Running');\n  \n}\n"
        }
      },
      "setup": "",
      "teardown": ""
    },
    "additionalPackages": {
      "hash": {
        "type": "npm",
        "content": "hash-anything",
        "name": "hash"
      },
      "axios": {
        "type": "npm",
        "content": "axios",
        "name": "axios"
      }
    }
  },
  "history": [
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-22T13:06:27.957Z",
      "description": {
        "action": "Create"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-22T13:08:03.489Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-22T13:11:19.426Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-22T13:12:43.387Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-22T13:45:04.741Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-22T13:46:30.833Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d33d4a162fb2205cebc6f",
      "timestamp": "2022-04-25T06:30:23.947Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d33d4a162fb2205cebc6f",
      "timestamp": "2022-04-25T06:30:55.392Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T09:12:38.996Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T09:13:42.153Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T09:18:45.986Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T09:48:59.954Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T09:50:18.706Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T09:50:39.961Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T09:56:31.810Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T10:58:26.907Z",
      "description": {
        "action": "update"
      }
    },
    {
      "userId": "625d0c01a162fb2205cebc36",
      "timestamp": "2022-04-25T10:58:35.013Z",
      "description": {
        "action": "update"
      }
    }
  ]
}